# todo move extern stuff into a new contract
# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have receive a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import events as EVENTS
import fxpFunctions as FXP
import reporting as REPORTING
inset('refund.se')

macro ONEPOINTTWO: 22136092888451461120

macro POINTZEROONE: 184467440737095520

# [branchID][votingPeriod]
# reporthash is [reporterID] = hash
# subsidy is money for paying back a user for calculating the targeted num of reports for an event
data EventsExpDates[][](numberEvents, numberRemoved, events[], numEventsToReportOn, reportHash[][], shareValue, roundTwoNumEvents, subsidy[])

data EventIDToIndex[][]

# numReportsEvent is number of reports on an event, expected is how many have been committed for an event
# numReportsActual is the amount of reports a user has submitted in a period
# lesserReportNum is the number of reports an event should have [the lesser of how many it can afford from fees and how many it should have due to outstanding share value]
# periodRepConstant is 
data branches[](beforeRep[][], afterRep[][], periodDormantRep[][], ethics[][](event[]), report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], numReportsActual[][], repEvent[][], lesserReportNum[][], periodRepConstant[][], reportersPaidSoFarForEvent[])

data requiredEvents[]

# branch, period as params
data numReqEvents[][]

data mode_items[][](report_value[], current_mode, current_mode_items)

def getReportersPaidSoFar(branch, event):
    return(self.branches[branch].reportersPaidSoFarForEvent[event])

def addReportersPaidSoFar(branch, event):
    self.branches[branch].reportersPaidSoFarForEvent[event] += 1
    return(1)
    
def refundCost(to, value):
    send(to, value)
    return(1)

def getSubsidy(branch, period, event):
    return(self.EventsExpDates[branch][period].subsidy[event])

def getPeriodRepConstant(branch, votePeriod, sender):
    return(self.branches[branch].periodRepConstant[votePeriod][sender])

def setPeriodRepConstant(branch, votePeriod, sender, value):
    self.branches[branch].periodRepConstant[votePeriod][sender] = value
    return(1)

def getLesserReportNum(branch, period, event):
    return(self.branches[branch].lesserReportNum[period][event])

def getCurrentModeItems(period, event):
    return(self.mode_items[period][event].current_mode_items)

def getCurrentMode(period, event):
    return(self.mode_items[period][event].current_mode)
    
# returns weight of a report value for the mode
def getWeightOfReport(period, event, report):
    return(self.mode_items[period][event].report_value[report])

def getRepEvent(branch, votePeriod, event):
    return(self.branches[branch].repEvent[votePeriod][event])

def getEthicReport(branch, period, event, sender):
    return(self.branches[branch].ethics[period][sender].event[event])

def getNumReportsExpectedEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])

def getNumReportsEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsEvent[votePeriod][eventID])

def getReport(branch, period, event, sender):
    #if(whitelist):
    return(self.branches[branch].report[period][sender].event[event])

def getBeforeRep(branch, period, sender):
    return(self.branches[branch].beforeRep[period][sender])

def getAfterRep(branch, period, sender):
    return(self.branches[branch].afterRep[period][sender])
    
def getPeriodDormantRep(branch, period, sender):
    return(self.branches[branch].periodDormantRep[period][sender])

def getNumReportsActual(branch, votePeriod, sender):
    return(self.branches[branch].numReportsActual[sender][votePeriod])

def getNumRoundTwo(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].roundTwoNumEvents)

def addRoundTwo(branch, period):
    refund()
    self.EventsExpDates[branch][period].roundTwoNumEvents += 1
    return(1)

def getRequired(event):
    return(self.requiredEvents[event])
    
def getNumRequired(branch, period):
    return(self.numReqEvents[branch][period])
    
# Return 0 means already required
def setEventRequired(branch, period, event):
    if(self.requiredEvents[event]==0):
        self.requiredEvents[event] = 1
        self.numReqEvents[branch][period] += 1
        return(1)
    else:
        return(0)

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)
    
# 0, event means calculateReportTargetForEvent(branch, eventID, votePeriod, sender) in make reports should be called for that event
def getEventsToReportOn(branch, expDateIndex, sender):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents*2)
    i = 0
    while i < numEvents:
        if(self.getLesserReportNum(branch, votePeriod, event)==0):
            return([0, event]: arr)
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        reportingThreshold = self.calculateReportingThreshold(branch, events[i], expDateIndex, sender)
        x = array(1)
        x[0] = sender + events[i]
        # add 2**255 to ensure pos. and between 0 and 1
        shaHash = (sha3(x, items=1)+2**255)/ONE
        if((shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(events[i]) || self.getRequired(events[i])) && !EVENTS.getOutcome(events[i])):
            events[i+1] = 1
        else:
            events[i+1] = 0
        i += 2
    return(events: arr)
    
def getEventCanReportOn(branch, expDateIndex, reporter, event):
    refund()
    reportingThreshold = self.calculateReportingThreshold(branch, event, expDateIndex, reporter)
    x = array(1)
    x[0] = reporter + event
    # add 2**255 to ensure pos. and between 0 and 1
    shaHash = (sha3(x, items=1)+2**255)/ONE
    if(shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(event) || self.getRequired(events)):
        return(1)
    else:
        return(0)

# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # exp(1.2*ln(repbal)) / exp(1.2*ln(totalrep)) is == (reporterList[n]/totalRep)**1.2
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
def calculateReportingThreshold(branch, eventID, votePeriod, sender):
    repConstant = self.getPeriodRepConstant(branch, votePeriod, sender)
    if(repConstant==0):
        repConstant = FXP.fx_exp(ONEPOINTTWO*FXP.fx_log(REPORTING.getRepBalance(branch, sender))/ONE)*2**64/FXP.fx_exp(ONEPOINTTWO*FXP.fx_log(REPORTING.getActiveRep(branch))/ONE)
        expectedEventsForReporter = repConstant * self.getNumEventsToReportOn(branch, votePeriod)
        total = expectedEventsForReporter
        eventsInPeriod = self.getNumberEvents(branch, expDateIndex)-self.getNumRemoved(branch, votePeriod)
        numRequiredEvents = self.getNumRequired(branch, votePeriod)
        if(repFraction >= POINTZEROONE):
            minimum = min(30-numRequiredEvents, eventsInPeriod-numRequiredEvents)
            if(total/ONE < minimum):
                total = minimum*ONE
                repConstant = total / self.getNumEventsToReportOn(branch, votePeriod)
        self.setPeriodRepConstant(branch, votePeriod, sender, repConstant)
    # 1 is 2**192 here, lesserreportnum, repconstant, and one are all base 2**64
    reportingThreshold = self.getLesserReportNum(branch, votePeriod, eventID)*repConstant*ONE
    return(reportingThreshold)
    
def getEventsRange(branch, expDateIndex, start, end):
    refund()
    numEvents = end-start
    events = array(numEvents)
    i = start
    index = 0
    while i < end:
        events[index] = self.EventsExpDates[branch][expDateIndex].events[i]
        index += 1
        i += 1
    return(events: arr)
    
def getEventIndex(period, eventID):
    refund()
    return(self.EventIDToIndex[period][eventID])

# we should probably make this bonded too
# -1: voting not started
def setNumEventsToReportOn(branch):
    refund()
    # after voting has started
    expDateIndex = BRANCHES.getVotePeriod(branch)
    self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = (self.EventsExpDates[branch][expDateIndex].numberEvents - self.numReqEvents[branch][expDateIndex] - self.EventsExpDates[branch][expDateIndex].numberRemoved)*BRANCHES.getBaseReporters(branch)
    return(1)

def getNumEventsToReportOn(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)

def getShareValue(branch, expIndex):
    refund()
    return(self.EventsExpDates[branch][expIndex].shareValue)

def getNumberEvents(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, eventIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getReportHash(branch, expDateIndex, reporter, event):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID, subsidy):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
    self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents
    self.EventsExpDates[branch][futurePeriod].numberEvents += 1
    self.EventsExpDates[branch][futurePeriod].subsidy[eventID] += subsidy
    return(1)

def deleteEvent(branch, period, event):
    i = self.EventIDToIndex[period][event]
    self.EventsExpDates[branch][period].events[i] = 0
    self.EventIDToIndex[period][event] = 0
    return(1)

def removeEvent(branch, period):
    refund()
    self.EventsExpDates[branch][period].numberRemoved += 1
    return(1)

def getNumRemoved(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].numberRemoved)

def adjustPeriodShareValueOutstanding(branch, expIndex, amount):
    refund()
    self.EventsExpDates[branch][expIndex].shareValue += amount
    return(1)

def setReportHash(branch, expDateIndex, reporter, reportHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash
    return(1)

# called in case an event doesn't get reported on at all in a period
def moveEvent(branch, event):
    if(BRANCHES.getVotePeriod(branch) > EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch) && !EVENTS.getUncaughtOutcome(event)):
        # add to next expiration period
        self.addEvent(branch, block.timestamp/BRANCHES.getPeriodLength(branch), event)
        EVENTS.setExpiration(event, block.timestamp)
        return(1)
    else:
        return(0)
        
def addToWeightOfReport(period, event, report, amount):
    self.mode_items[period][event].report_value[report] += amount
    return(1)
    
def setCurrentMode(period, event, mode):
    self.mode_items[period][event].current_mode = mode
    return(1)
    
# basically setting current mode's weight
def setCurrentModeItems(period, event, modeReport):
    self.mode_items[period][event].current_mode_items = self.mode_items[period][event].report_value[modeReport]
    return(1)

def addRepEvent(branch, votePeriod, event, amount):
    self.branches[branch].repEvent[votePeriod][event] += amount
    return(1)

def setEthicReport(branch, period, event, ethics, sender):
    self.branches[branch].ethics[period][sender].event[event] = ethics
    return(1)

def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num
    return(1)

def setNumReportsEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsEvent[votePeriod][eventID] = num
    return(1)
    
def addReportToEvent(branch, votePeriod, eventID, sender):
    self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
    self.branches[branch].numReportsActual[sender][votePeriod] += 1
    return(1)

def addReportExpected(branch, votePeriod, eventID):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1
    return(1)

def setReport(branch, period, event, report, sender):
    self.branches[branch].report[period][sender].event[event] = report
    return(1)

def setBeforeRep(branch, period, rep, sender):
    self.branches[branch].beforeRep[period][sender] = rep
    return(rep)

def setAfterRep(branch, period, rep, sender):
    self.branches[branch].afterRep[period][sender] = rep
    return(rep)

def setPeriodDormantRep(branch, period, rep, sender):
    self.branches[branch].periodDormantRep[period][sender] = rep
    return(rep)
    
def setLesserReportNum(branch, period, event, num):
    self.branches[branch].lesserReportNum[period][event] = num
    return(1)
    
#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.
def setReportingThreshold(event):
    refund()
    # first check is if event expDate is in the current vote period and second is if blockNum is near expiration of commit period (within 24 hr.)
    # final check is if < 3 reports so far
    # so if in 24 hr we'd be in the next half of the vote period, we're within 24 hr of the end of this one
    branch = EVENTS.getBranch(event)
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    votePeriod = BRANCHES.getVotePeriod(branch)
    if(votePeriod==EVENTS.getExpiration(event)/periodLength and (((block.timestamp + TWENTYFOURHR) % periodLength) > periodLength/2) and self.branches[branch].numReportsExpectedEvent[votePeriod][event]<3):
        EVENTS.setThreshold(event, 2**192)
        return(1)
    else:
        return(0)