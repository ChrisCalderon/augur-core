def init():
    self.baseReportersLastPeriod[1010101] = 2*3
    description = text("Root branch")
    save(self.Info[1010101].description[0], description, chars=len(description))
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Info[1010101].descriptionLength = len(description)
    self.Reporting[1010101].repIDtoIndex[msg.sender] = 0
    self.Reporting[1010101].reputation[0].repValue = 0
    self.Reporting[1010101].reputation[0].reporterID = msg.sender
    self.Reporting[1010101].numberReporters = 2
    self.Reporting[1010101].repIDtoIndex[1010101] = 1
    self.Reporting[1010101].reputation[1].repValue = 0
    self.Reporting[1010101].reputation[1].reporterID = 1010101
    self.Branches[1010101].currentVotePeriod = (block.timestamp / 15) - 1
    self.Branches[1010101].periodLength = 15
    # .5%
    self.Branches[1010101].minTradingFee = 92233720368547760 
    self.branchListCount = 1
    self.branchList[0] = 1010101
    # since only have to report on half this targets 3
    self.Branches[1010101].baseReporters = 2*3
    # test initial funds
    self.cashcoinBalances[msg.sender] = 100000*ONE

inset('refund.se')

# Error -1: Hey, you're not broke!
def cashFaucet():
    refund()
    if self.balance(msg.sender) > 5*ONE:
        return(-1)
    self.setCash(msg.sender, 10000*ONE)
    return(1)

def reputationFaucet(branch):
    refund()
    if self.repIDToIndex(branch, msg.sender) != 0 or self.getReporterID(branch, 0) == msg.sender:
        index = self.repIDToIndex(branch, msg.sender)
    else:
        index = self.getNumberReporters(branch)
        self.addReporter(branch, msg.sender, 0, 0, 0)
    self.setRep(branch, index, 47*ONE)
    self.initialPenalizedSetting(branch, msg.sender, (self.getVotePeriod(branch)-1))
    return(1)

def fundNewAccount(branch):
    self.send(self, 0)
    self.reputationFaucet(branch)
    self.setCash(msg.sender, 10000*2^64)
    return(1)

def claimInitialRep(parent, branch):
    refund()
    if(self.getParent(branch)!=parent):
        return(0)
    # have 1 month to claim
    if(self.repIDToIndex(branch, msg.sender)==0 && block.timestamp < (self.getCreationDate(branch) + TWENTYFOURHR*30)):
        parentPeriod = self.getParentPeriod(branch)
        forkPeriod = self.getForkPeriod(parent)
        fork = self.getFork(branch)
        forkEvent = self.getEventForkedOver(parent)
        report = self.getReport(parent, forkPeriod, forkEvent, msg.sender)
        outcome = self.getUncaughtOutcome(forkEvent)
        if(binary(forkEvent)):
            outcome = catch(outcome)
        ethical = ethic_catch(self.getEthical(forkEvent))
        ethicReport = self.getEthicReport(parent, forkPeriod, forkEvent, msg.sender)
        rep = self.getBeforeRep(parent, parentPeriod, msg.sender)
        repDecrease = 0
        if(fork && (report==outcome || report==0 || (self.getForkedOverEthicality(forkEvent) && ethical==ethicReport))):
            # take away 30% of rep from liars and those who didn't report
            repDecrease = rep*12912720851596685312/ONE
            rep = rep - repDecrease
            amountLeftToPayBonder = self.getBondAmount(forkEvent) - self.getBondPaid(forkEvent)
            if(repDecrease < amountLeftToPayBonder):
                # send all the rep to the fork bond poster
                self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(forkEvent)), repDecrease)
            else:
                # send amountLeftToPayBonder [if positive] to the fork bond poster
                if(amountLeftToPayBonder > 0):
                    self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(forkEvent)), amountLeftToPayBonder)    
                    # send the rest to the new branch's redistribution pool
                    self.subtractRep(branch, self.repIDToIndex(branch, branch), (repDecrease - amountLeftToPayBonder))
                else:
                    # send to new branch's redistribution pool
                    self.subtractRep(branch, self.repIDToIndex(branch, branch), repDecrease)
        if(fork):
            self.initialPenalizedSetting(branch, msg.sender, forkPeriod)
        else:
            self.initialPenalizedSetting(branch, msg.sender, (self.getVotePeriod(branch)-1))
        dormantRep = self.getPeriodDormantRep(parent, self.getParentPeriod(branch), msg.sender)
        self.addReporter(branch, msg.sender, rep, dormantRep, repDecrease)
        return(1)
    else:
        # already claimed or too late
        return(0)
        
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

#event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)
event log_add_tx(market:indexed, sender, type, price, amount, outcome, tradeid)
#event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)
event log_cancel(market:indexed, sender, price, amount, tradeid, outcome, type)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
macro FAILURE: 0
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_ALREADY_EXISTS: 21
macro TRADE_SAME_BLOCK_PROHIBITED: 22

macro fee_percent($market_fee, $price, $cumScale):
    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)

macro save_trade($type, $amount, $price, $market, $outcome, $branch, $participantNumber, $fee, $sender):
    trade = [$type, $market, $amount, $price, $sender, block.number, $outcome]
    trade_id = sha256(trade, items=7)
    cumScale = self.getCumScale($market)

    # Save trade
    if !self.getID(trade_id):
        self.saveTrade(trade_id, $type, $market, $amount, $price, $sender, $outcome)
        # Update market
        last_id = self.getLastTrade($market)
        self.addTrade($market, trade_id, last_id)
        # Update available and trading amounts for asks
        if $type == ASK:
            self.modifyParticipantShares($market, $participantNumber, $outcome, -$amount, 0)
            if($fee):
                self.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)
        # Send / escrow cash for bids
        if $type == BID:
            self.sendFrom($market, $amount * $price / ONE, $sender)
            if($fee):
                self.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)
    else:
        return(TRADE_ALREADY_EXISTS)
    log(type=log_add_tx, $market, $sender, $type, $price, $amount, $outcome, trade_id)
    return(trade_id)

#
# Cancellation
#
# 200k gas
def cancel(trade_id):
    refund()
    # user can cancel anytime
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = self.get_trade(trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(0)
    type = trade[1]
    market = trade[2]
    amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    branch = self.getBranchID(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    # Check the owner
    if msg.sender == owner:
        # Clear the trade first
        remove_trade(trade_id, market)
        # Issue refunds
        if type == BID:
            # cash refund
            amt = amount * price * (fee + ONE) / ONE^2
            self.subtractCash(market, amt)
            self.addCash(msg.sender, amt)
        elif type == ASK:
            # shares refund
            participantNumber = self.getParticipantNumber(market, msg.sender)
            self.modifyParticipantShares(market, participantNumber, outcome, amount, 1)
            self.subtractCash(market, (amount * price * fee / ONE^2))
            self.addCash(msg.sender, (amount * price * fee / ONE^2))
        # Log cancellation
        log(type=log_cancel, market, msg.sender, price, amount, trade_id, outcome, type)
        return(SUCCESS)
    return(FAILURE)

macro remove_trade($trade_id, $market):
    self.remove_trade($trade_id)
    self.remove_trade_from_market($market, $trade_id)

#
# Buy / Sell actions
# Errors:
    # -1: amount/price bad or no market
    # -2: oracle only branch
    # -3: bad outcome to trade [not needed anymore, can't buy shares that don't exist]
    # -4: not enough money or shares
#
# costs 532k
# smallest trade value is 0.00000001
def buy(amount, price, market, outcome):
    refund()
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-2)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    if(price>cumScale or amount*price < 3402823669209384705829531287552 or amount*price >= 2**190):
        return(0)
    if(self.balance(msg.sender) < (amount * price * (fee + ONE) / ONE^2)):
        return(-4)
    save_trade(BID, amount, price, market, outcome, branch, participantNumber, fee, msg.sender)
    return(FAILURE)

# cost 532k
# smallest trade value is 0.00000001
def sell(amount, price, market, outcome):
    refund()
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-2)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    if(self.getParticipantID(market, participantNumber) != msg.sender):
        return(-3)
    if(self.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):
        return(-4)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    if(price>cumScale or amount*price < 3402823669209384705829531287552L or amount*price >= 2**190):
        return(0)
    if(self.balance(msg.sender) < (amount * price * fee / ONE^2)):
        return(-4)
    save_trade(ASK, amount, price, market, outcome, branch, participantNumber, fee, msg.sender)
    return(FAILURE)

# Example:
    #buyer gives up say 20
    #complete set cost is say 100
    #fee is say 2
    #market should lose 20 from buyer's escrowed money
    #market should gain 100 from complete set
    #person short selling should give the market 80 [complete set cost less shares sold]
    #plus fees
        #1 should go to branch
        #1 should go to creator
def short_sell(buyer_trade_id, max_amount):
    refund()
    # check trade hash
    tradeInfo = array(3)
    tradeInfo[0] = buyer_trade_id
    tradeInfo[1] = max_amount
    tradeInfo[2] = 0
    tradeHash = sha256(tradeInfo, items=3)
    if(self.checkHash(tradeHash, msg.sender)==-1):
        return(-2)
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = self.get_trade(buyer_trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(3)
    # Get market
    type = trade[1]
    if(type!=BID):
        return(4)
    market = trade[2]
    if(self.getOneWinningOutcome(market, 0)):
        return(-4)
    orig_amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    if(owner == msg.sender or owner == tx.origin):
        return(5)
    # Make sure the trade has been mined, obvious HFT prevention
    if block.number <= trade[6]:
        return(TRADE_SAME_BLOCK_PROHIBITED)
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    creator = self.getCreator(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    amount = min(orig_amount, max_amount)
    if(amount < 0):
        return(INSUFFICIENT_BALANCE)
    fee = amount * price * fee_percent(trading_fee, price, cumScale) / ONE^2
    makerFeeRate = self.getMakerFees(market)
    branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
    creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
    takerFeesTotal = branchFees + creatorFees
    cost = amount*cumScale/ONE - (amount*price/ONE - takerFeesTotal)
    if(self.balance(msg.sender) < cost):
        return(INSUFFICIENT_BALANCE)

    if(amount*price/ONE < 184467440738):
        return(-4)

    numOutcomes = self.getMarketNumOutcomes(market)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)

    i = 1
    # send shares of the event to user address
    while i <= numOutcomes:
        self.modifyShares(market, i, amount)
        self.modifyParticipantShares(market, participantNumber, i, amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), amount*cumScale/ONE)

    # send money from user acc. to market address/account
    # cost for shares
    self.sendFrom(market, cost-takerFeesTotal, msg.sender)

    # Fill buy order
    # Determine fill amount
    fill = amount
    # Update trade amount or remove
    if fill < orig_amount:
        self.fill_trade(trade_id, fill)
    else:
        remove_trade(trade_id, market)
    # Update balances
    ownerNum = self.getParticipantNumber(market, owner)
    self.modifyParticipantShares(market, participantNumber, outcome, -fill, 0)
    self.modifyParticipantShares(market, ownerNum, outcome, fill, 0)
    # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
    # 75% to branch + .5% more to branch per maker fee 1% decrease 
    self.sendFrom(branch, branchFees, msg.sender)
    # 25% to creator + .5% more to creator per 1% decrease in maker fees
    self.sendFrom(creator, creatorFees, msg.sender)

    # other party [maker] pay their part of the fee here too
    fee = fee * makerFeeRate / ONE
    self.subtractCash(market, fee)
    self.addCash(creator, fee/2)
    self.addCash(branch, fee/2)
    
    self.addFees(market, fee+takerFeesTotal)

    # Log transaction
    log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)
    # Log price, fill amount, type and timestamp
    log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)
    return([SUCCESS, max_amount, fill, price]: arr)
inset('refund.se')

# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account and distributed like trading fees.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep
# Errors:
    # -1: already done
    # -2: hasn't reported this period
def penalizeNotEnoughReports(branch):
    refund()
    lastPeriod = self.getVotePeriod(branch)-1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(self.getNotEnoughPenalized(branch, msg.sender, lastPeriod)):
        return(-1)
    # accounts for if no events in a period
    if(self.getNumberEvents(branch, lastPeriod)==0):
        self.setNotEnoughPenalized(branch, msg.sender, lastPeriod)
        return(1)
    if(self.getForkPeriod(branch)+1 == lastPeriod):
        self.setNotEnoughPenalized(branch, msg.sender, lastPeriod)
        return(1)

    if(!self.getReportedPeriod(branch, lastPeriod, msg.sender)):
        return(-2)
    if(residual > periodLength/2):
        return(-2)
    numEvents = self.getNumEventsToReport(branch, lastPeriod)
    repConstant = self.getRepBalance(branch, msg.sender)*ONE/self.getActiveRep(branch)
    logOutput = self.fx_log(repConstant)
    exp = self.fx_exp(22136092888451461120*logOutput/ONE)
    exp += 18446744073709552
    baseReporters = self.getBaseReportersLastPeriod(branch)
    total = exp*baseReporters
    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*40 > 1)
    if(total > ONE):
        numEvents = (self.getNumEventsToReportOn(branch, votePeriod)/baseReporters)*ONE + self.getNumRequired(branch, votePeriod)
    numReportsActual = self.getNumReportsActual(branch, lastPeriod, msg.sender)
    if(numEvents/(2*ONE) > self.getNumReportsActual(branch, lastPeriod, msg.sender)):
        originalRep = self.getRepBalance(branch, msg.sender)
        # penalize people
        # can number reported on be greater than num expected to report on
        newRep = 3689348814741910528*numReportsActual*originalRep / numEvents
        oldRep = originalRep*14757395258967642112 / ONE
        repChange = (oldRep+newRep) - originalRep
        if(repChange > 0):
            return(1)
        # removes rep from reporter who lost it
        self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), -repChange)
        self.setBeforeRep(branch, lastPeriod, oldRep+newRep, msg.sender)
        self.setAfterRep(branch, lastPeriod, oldRep+newRep, msg.sender)
    self.setNotEnoughPenalized(branch, msg.sender, lastPeriod)
    return(1)
inset('refund.se')

# first param is the market, second param is the subcurrency contract
data cash[][]

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF

macro CATCH_TOLERANCE: ONE / 10

event thru(user:indexed, time)

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

# loop through events in the market, get their outcomes && use those to determine the winning events!
# distribute coins among winning events
# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1
# Error messages otherwise
    # -1: Market has no cash anyway / already closed
    # -2: 0 outcome / not reported on yet
    # -3: not final round 2 event
    # -4: Outcome .5 once, pushback and retry
    # -5: Event forked and not final yet
    # -6: bonded pushed forward market not ready to be resolved
    # -7: event not reportable >.99
    # -8: market isn't in branch
# if market's events have moved due to a fork branch is the new fork
def closeMarket(branch, market):
    refund()
    if(self.getBranchID(market)!=branch):
        return(-8)
    if(self.balance(market)<=0):
        return(-1)
    numberEvents = self.getNumEvents(market)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    events = array(3)
    events = self.getMarketEvents(market, outitems=3)
    i = 0
    reportingDone = 0
    resolved = 1
    while i < numberEvents:
        if(self.getOutcome(events[i])==0 && self.getmode(events[i])==0):
            resolved = 0
            i = numberEvents
        i += 1
    i = 0
    while i < numberEvents:
        numReports = self.getNumReportsEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        numExpected = self.getNumReportsExpectedEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        if(numReports == numExpected && numReports!=0 && numExpected!=0):
            reportingDone = 1
            i = numberEvents
        i += 1
    if((period > tradingPeriod || reportingDone) && !resolved):
        # loop through events in the market, get their outcomes && use those to determine the winning events!
        n = 0
        outcomeFour = 0
        outcomeSix = 0
        while n < numberEvents:
            votingPeriodEvent = self.getExpiration(events[n])/self.getPeriodLength(branch)
            fxpOutcome = self.getOutcome(events[n])
            resolution = 1
            if(self.getUncaughtOutcome(events[n])==0):
                return(-2)
            if(self.getRoundTwo(event) && !self.getFinal(event)):
                return(-3)
            forkPeriod = self.getForkPeriod(self.getEventBranch(events[n]))
            currentPeriod = block.timestamp / self.getPeriodLength(branch)
            if((self.getForked(event) && !self.getForkedDone(event)) or (currentPeriod <= (forkPeriod+2))):
                return(-5)
            if(binary(events[n]) && fxpOutcome==0):
                    resolution = self.resolveBinary(events[n], market, branch, votingPeriodEvent, msg.sender)
            elif(scalar(events[n]) && self.getmode(events[n])==0):
                    resolution = self.resolveCategoricalOrScalar(self.getMinValue(events[n]), self.getMaxValue(events[n]), events[n], market, branch, votingPeriodEvent, msg.sender)
            elif(categorical(events[n]) && self.getmode(events[n])==0):
                    resolution = self.resolveCategoricalOrScalar(ONE, ONE*self.getNumOutcomes(events[n]), events[n], market, branch, votingPeriodEvent, msg.sender)
            elif(resolution==-6):
                outcomeSix = 1
            n += 1
        if(outcomeFour):
            return(-4)
        elif(outcomeSix):
            return(-6)
        winningOutcomes = array(8)
        winningOutcomes = self.determineWinningOutcomes(events, numberEvents, branch, market, outitems=8)
        self.setWinningOutcomes(market, winningOutcomes)
        self.refundClosing(self.getgasSubsidy(market), msg.sender)
        return(1)
    else:
        return(0)

# @return 1 if success
# Errors:
    # 0: reporting not done
    # -1: trader doesn't exist
def claimProceeds(branch, market):
    refund()
    if(self.getBranchID(market)!=branch):
        return(-8)
    numberEvents = self.getNumEvents(market)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    events = array(3)
    events = self.getMarketEvents(market, outitems=3)
    i = 0
    reportingDone = 1
    resolved = 1
    while i < numberEvents:
        numReports = self.getNumReportsEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        numExpected = self.getNumReportsExpectedEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        if(self.getOutcome(events[i])==0 && self.getmode(events[i])==0):
            resolved = 0
        if(numReports != numExpected && numReports!=0 and numExpected!=0):
            reportingDone = 0
            i = numberEvents
        i += 1
    if((period > tradingPeriod || reportingDone) && resolved):
        winningOutcomes = array(8)
        winningOutcomes = self.getWinningOutcomes(market, outitems=8)
        outcome = 0
        # market not resolved
        if(winningOutcomes[0]==0):
            return(0)
        if(winningOutcomes[1]==0):
            outcome = self.oneOutcome(market, winningOutcomes[0], msg.sender)
        elif(winningOutcomes[7]):
            outcome = self.eightOutcomes(market, winningOutcomes, events, msg.sender)
        elif(winningOutcomes[3]):
            outcome = self.fourOutcomes(market, winningOutcomes, events, msg.sender)
        elif(winningOutcomes[1]):
            outcome = self.twoOutcomes(market, winningOutcomes, events, msg.sender)
        return(outcome)
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro binary($event):
    (self.getNumOutcomes($event)==2 and ONE*self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

macro categorical($event):
    (self.getNumOutcomes($event)>2)
inset('refund.se')

# period length is given in blocks
# @return branchID if success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: no money for creation fee or branch already exists
def createSubbranch(description:str, periodLength, parent, tradingFee, oracleOnly):
    refund()
    if(periodLength<=0 || !self.getPeriodLength(parent) || description==0):
        return(-1)

    if(tradingFee < 0 or tradingFee > 2**62):
        return(-1)
    parentPeriod = self.getVotePeriod(parent)

    branchInfo = string(8*32+len(description))
    branchInfo[0] = BRANCH                                      #typecode
    branchInfo[1] = tx.origin                                   #creator address
    branchInfo[2] = 47*ONE                                     #creation fee
    branchInfo[3] = periodLength                                #length of voting cycle
    branchInfo[4] = block.timestamp                             #current blocktime
    branchInfo[5] = parent                                      #branchID of parent branch
    branchInfo[6] = tradingFee
    branchInfo[7] = oracleOnly
    mcopy(branchInfo+ 8*32, description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
    branchID = sha256(branchInfo, chars=len(branchInfo))
    currentVotePeriod = (block.timestamp / periodLength) - 1
    if(self.getCreator(branchID)==0):
        self.initializeBranch(branchID, currentVotePeriod, periodLength, tradingFee, oracleOnly, parentPeriod, parent)
    else:
        return(-2)
    if(self.getCreator(parent) && self.sendFrom(parent, 47*ONE, msg.sender) && self.setInfo(branchID, description, tx.origin, 47*ONE) && self.setInitialReporters(parent, branchID)):
        return(branchID)
    else:
        return(-2)

inset('refund.se')

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
# @return eventID if success
# error messages otherwise
    # -1: we're either already past that date, branch doesn't exist, or description is bad
    # 0: not enough money to pay fees or event already exists
    # -2: max value < min value
# .025 eth to create
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    periodLength = self.getPeriodLength(branch)
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod && ((expDate / periodLength)==forkPeriod or (expDate / periodLength)==(forkPeriod+1))):
        return(-9)
    if(maxValue < minValue or (maxValue-minValue) < ONE):
        return(-2)
    eventID = 0
    if(periodLength && description != 0 && expDate > block.timestamp):
        eventinfo = string(8*32 + len(description))
        eventinfo[0] = EVENT                                        #typecode
        eventinfo[1] = branch                                       #branchID
        eventinfo[2] = expDate                                      #expiration date
        eventinfo[3] = msg.sender                                   #creator address
        eventinfo[4] = periodLength
        eventinfo[5] = minValue                                     #minimum outcome value
        eventinfo[6] = maxValue                                     #maximum outcome value
        eventinfo[7] = numOutcomes                                  #number of outcomes
        mcopy(eventinfo + 8*32, description, len(description))
        eventID = sha256(eventinfo, chars=len(eventinfo))
    else:
        return(-1)
    if(numOutcomes < 2 || numOutcomes > 8):
        return(0)
    currentVotePeriod = self.getVotePeriod(branch)
    self.initiateOwner(eventID)
    if(!self.getCreator(eventID)):
        # see which future period it expires in && put the event in that bin
        # event voting periods - expDate / periodLength gives you the voting period #
        futurePeriod = expDate / periodLength
        if(self.setInfo(eventID, description, msg.sender, 0) && self.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes, resolution)):
            return(eventID)
        else:
            return(0)
    else:
        return(0)
inset('refund.se')

# # of winningOutcomes is 2
def twoOutcomes(market, winningOutcome: arr, events: arr, sender):
    refund()
    # look for the scalar
    scalar = 0
    if(((self.getMaxValue(events[0])!=TWO || self.getMinValue(events[0])!=ONE) && self.getNumOutcomes(events[0])==2) || self.getOutcome(events[0])==3*ONEHALF):
        scalar = 0
    elif(((self.getMaxValue(events[1])!=TWO || self.getMinValue(events[1])!=ONE) && self.getNumOutcomes(events[1])==2) || self.getOutcome(events[1])==3*ONEHALF):
        scalar = 1
    elif(((self.getMaxValue(events[2])!=TWO || self.getMinValue(events[2])!=ONE) && self.getNumOutcomes(events[2])==2) || self.getOutcome(events[2])==3*ONEHALF):
        scalar = 2
    outcome = self.getOutcome(events[scalar])
    minValue = self.getMinValue(events[scalar])
    maxValue = self.getMaxValue(events[scalar])
    if(outcome>maxValue):
        outcome = maxValue
    elif(outcome<minValue):
        outcome = minValue
    # price is in fixed point
    # share two goes with the high side
    pricePerShare2 = ONE*(outcome - minValue) / (maxValue - minValue)
    #share one goes with the low side of the calc
    pricePerShare1 = ONE - pricePerShare1
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, sender)
    participant = self.getParticipantID(market, participantNumber)
    # for each winning outcome do...
    n = 0
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)
        # low side
        if(n==0):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/ONE*pricePerShare1/ONE)
            self.addCash(participant, sharesOwned*self.getCumScale(market)/ONE*pricePerShare1/ONE)
        # high side (of the scalar part)
        elif(n==1):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/ONE*pricePerShare2/ONE)
            self.addCash(participant, sharesOwned*self.getCumScale(market)/ONE*pricePerShare2/ONE)
        n+=1
    return(1)
inset('refund.se')

def makeHash(salt, report, eventID, sender):
    hashInfo = array(4)
    hashInfo[0] = sender
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha256(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# Error -1: invalid event
# Error -2: not in first half of period [commit part]
def submitReportHash(event, reportHash):
    branch = self.getBranch(event)
    votePeriod = self.getVotePeriod(branch)
    # first report of period, num events not set
    if(self.getNumEventsToReportOn(branch, votePeriod)==0):
        self.setNumEventsToReportOn(branch)
        self.setInitialBalance(branch, votePeriod, self.balance(branch))
    eventIndex = self.getEventIndex(votePeriod, event)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-1)
    reportingThreshold = 0
    if(self.getRequired(event) || self.getReportingThreshold(event)):
        reportingThreshold = 2**192
    else:
        if(self.getLesserReportNum(branch, votePeriod, event)==0):
            self.setLesserReportNum(branch, votePeriod, event, self.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender))
        reportingThreshold = self.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    x = array(1)
    x[0] = msg.sender + event
    # div by ONE b/c is out of 2**192 rather than 2**256 [to avoid looping around]
    shaHash = sha3(x, items=1)/ONE
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2 && shaHash <= reportingThreshold):
        if(self.getReportHash(branch, votePeriod, msg.sender, event)==0):
            self.addReportExpected(branch, votePeriod, event)
        self.setReportHash(branch, votePeriod, msg.sender, reportHash, event)
        return(1)
    return(-2)

# @return 1 if success
# Error messages
    # 0: reporter doesn't exist or has <.5 rep
    # -1: has already reported
    # -2: not in second half of period [reveal part]
    # -3: hash doesn't match
    # -4: bad report
    # -5: invalid event
    # -6: already resolved
    # -7: <48 hr left in period, too late to report, able to put up readj. bonds though
def submitReport(event, salt, report, ethics):
    branch = self.getBranch(event)
    balance = self.getRepBalance(branch, msg.sender)
    if(balance<ONEHALF):
        return(0)
    votePeriod = self.getVotePeriod(branch)
    if(self.getReport(branch, votePeriod, event, msg.sender)):
        return(-1)
    eventIndex = self.getEventIndex(votePeriod, event)
    # makes sure event is in the given branch and vote period
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-5)
    elif(self.getOutcome(event)!=0):
        return(-6)
    periodLength = self.getPeriodLength(branch)
    # commented out for testing
    #if(block.timestamp/periodLength!=((block.timestamp + 2*TWENTYFOURHR)/periodLength)):
    #    return(-7)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        realHash = self.getReportHash(branch, votePeriod, msg.sender, event)
        if(self.makeHash(salt, report, eventID, msg.sender)!=realHash || realHash==0):
            return(-3)
        # forkedOverEthicality = self.getForkedOverEthicality(event)
        forkedOverThisEvent = 0
        if(self.getEventForkedOver(branch) == event):
            forkedOverThisEvent = 1
        roundTwo = self.getRoundTwo(event)
        report = self.validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance)
        if(report == -4):
            return(-4)
        self.setReport(branch, votePeriod, eventID, report, msg.sender)
        # set ethics value for event
        ethics = ethics
        if(ethics!=ONE || ethics!=0):
            ethics = ONE
        if(forkedOverThisEvent):
            # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality
            if(forkedOverEthicality):
                oldEthical = ethic_catch(self.getEthical(event))
                if(oldEthical == ONE):
                    ethics = 0
                else:
                    ethics = ONE
            self.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
            ethics = (self.getForkEthicality(event)*self.getRepEvent(branch, votePeriod, event) + ethics*balance) / (self.getRepEvent(branch, votePeriod, event) + balance)
            self.setForkEthicality(event, ethics)
        else:
            self.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
            if(roundTwo):
                ethics = (self.getEthics(event)*self.getRepEvent(branch, votePeriod, event) + ethics*balance) / (self.getRepEvent(branch, votePeriod, event) + balance)
            else:
                ethics = (self.getEthics(event)*self.getNumReportsEvent(branch, votePeriod, event) + ethics) / (self.getNumReportsEvent(branch, votePeriod, event) + 1)
            self.setEthics(eventID, ethics)
        self.addReportToEvent(branch, votePeriod, eventID, msg.sender)
        self.addRepEvent(branch, votePeriod, event, self.getBeforeRep(branch, period, msg.sender))
        # if 1st report of the period for a reporter
        if(!self.getReportedPeriod(branch, votePeriod, msg.sender)):
            dormantRep = self.balanceOf(branch, msg.sender)
            # Record rep at start of report period
            self.setBeforeRep(branch, votePeriod, balance, msg.sender)
            self.setAfterRep(branch, votePeriod, balance, msg.sender)
            self.setPeriodDormantRep(branch, votePeriod, dormantRep, msg.sender)
            self.setReportedPeriod(branch, votePeriod, msg.sender)
        return(1)
    return(-2)

# validates and submits report
# weights reports by rep if round 2 and fork
def validateReport(eventID, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance):
    outcome = 0
    # binary
    if(self.getNumOutcomes(eventID)==2 and self.getMaxValue(eventID)==TWO && self.getMinValue(eventID)==ONE):
        if(report>2*ONE or report<ONE or report==0):
            return(-4)
        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        elif(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if didn't fork over ethics
            if(!forkedOverEthicality && report == catch(self.getUncaughtOutcome(eventID))):
                return(-4)
            outcome = (self.getForkOutcome(eventID)*self.getRepEvent(branch, votePeriod, eventID) + report*balance) / (self.getRepEvent(branch, votePeriod, eventID) + balance)
            self.setForkOutcome(eventID, outcome)
        else:
            if(roundTwo):
                outcome = (self.getUncaughtOutcome(eventID)*self.getRepEvent(branch, votePeriod, eventID) + report*balance) / (self.getRepEvent(branch, votePeriod, eventID) + balance)
            else:
                outcome = (self.getUncaughtOutcome(eventID)*self.getNumReportsEvent(branch, votePeriod, eventID) + report) / (self.getNumReportsEvent(branch, votePeriod, eventID) + 1)
            self.setUncaughtOutcome(eventID, outcome)
    # scalar or categorical
    else:
        if(report > ONE):
            report = ONE
        elif(report<=0):
            # 1 is the new 0
            report = 1
        # in case of fork remove the original outcome as a possible response if didn't fork over ethics
        if(forkedOverThisEvent):
            if(!forkedOverEthicality && report == self.getUncaughtOutcome(eventID)):
                return(-4)
            # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
            self.addToWeightOfReport(votePeriod, eventID, report, balance)
            if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                self.setCurrentMode(votePeriod, event, report)
                self.setCurrentModeItems(votePeriod, eventID, report)
            outcome = self.getCurrentMode(votePeriod, eventID)
            self.setForkOutcome(eventID, outcome)
        else:
            if(roundTwo):
                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                self.addToWeightOfReport(votePeriod, eventID, report, balance)
                if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                    self.setCurrentMode(votePeriod, event, report)
                    self.setCurrentModeItems(votePeriod, eventID, report)
                outcome = self.getCurrentMode(votePeriod, eventID)
            else:
                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                self.addToWeightOfReport(votePeriod, eventID, report, 1)
                if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                    self.setCurrentMode(votePeriod, event, report)
                    self.setCurrentModeItems(votePeriod, eventID, report)
                outcome = self.getCurrentMode(votePeriod, eventID)
            self.setUncaughtOutcome(eventID, outcome)
    return(report)

### Helper functions:
def calculateReportTargetForEvent(branch, eventID, votePeriod, sender):
    numMarkets = self.getNumMarkets(eventID)
    if(numMarkets>25):
        numMarkets = 25
    markets = array(numMarkets)
    markets = self.getMarkets(eventID, outitems=numMarkets)
    totalFees = 0
    shareValue = 0
    i = 0
    while i < numMarkets:
        shareValue += self.getSharesValue(markets[i])
        totalFees += self.getFees(markets[i])
        i += 1
    totalVal = self.getShareValue(branch, votePeriod)
    shareFraction = shareValue*ONE/totalVal
    numReportersOnMarket = self.getBaseReporters(branch)*((-(267*shareFraction**2)/(2*ONE) + (533*shareFraction)/2 + 1*ONE))
    totalFeesInWei = totalFees * WEITOETH / ONE
    canPayForThisManyReporters = totalFeesInWei/(3500000*tx.gasprice)
    lesser = max(canPayForThisManyReporters*ONE, numReportersOnMarket)
    self.refundCost(sender, self.getSubsidy(branch, votePeriod, eventID))
    return(lesser)

# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
# returns num events to report on in fxp
def getNumEventsToReport(branch, votePeriod):
    prelim = self.getNumEventsToReportOn(branch, votePeriod)
    repConstant = self.getRepBalance(branch, msg.sender)*ONE/self.getActiveRep(branch)
    logOutput = self.fx_log(repConstant)
    exp = self.fx_exp(22136092888451461120*logOutput/ONE) + 18446744073709552
    total = exp*prelim + self.getNumRequired(branch, votePeriod)*ONE
    eventsInPeriod = self.getNumberEvents(branch, expDateIndex)-self.getNumRemoved(branch, votePeriod)
    minimum = min(30+self.getNumRequired(branch, votePeriod), eventsInPeriod)
    if(total/ONE < minimum):
        total = minimum*ONE
    return(total)
    
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')


macro POINTZEROSIX: 1106804644422573056

#data CLOSEMARKET

#def init():
#    self.CLOSEMARKET = 0

#def setCloseMarket(value):
#    if(!self.CLOSEMARKET):
#        self.CLOSEMARKET = value
#    return(1)

# tradingFee is a percent in fixedPoint
# @return marketID if success or 1 if on an oracle only branch creation we have success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: too many events
    # -3: too many outcomes
    # -4: not enough money
    # -5: fee too low
    # -6: duplicate events
    # -7: event already expired
    # -8: market already exists
    # -9: would expire during non-reporting fork period
# .05 eth to create
# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)
def createMarket(branch, description:str, tradingFee, events:arr, tag1, tag2, tag3, makerFees, extraInfo:str):
    if(makerFees<0 or makerFees > ONEHALF):
        return(0)
    periodLength = self.getPeriodLength(branch)
    # send this to branch
    creationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / (2*tradingFee)
    # gives ether/cash amount in fixed point
    minFee = 3500000*self.getBaseReporters(branch)*tx.gasprice*len(events)*ONE/WEITOETH
    if(creationFee < minFee):
        creationFee = minFee
    if(self.balance(msg.sender) < creationFee):
        return(-4)
    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets
    if(periodLength==0 or len(description)==0 || tradingFee < self.getMinTradingFee(branch)):
        return(-1)
    if(tradingFee > 2^61):
        return(-1)
        
    event = events[0]
    # check that events have same exp. dates && branch
    i = 0
    eventNum = len(events)
    # only supports upto 3 dimensional markets
    if(eventNum > 3):
        return(-2)
    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
        event = events[i]
        if(i!=0):
            if(event==events[i-1]):
                return(-6)
        expirationDate = self.getExpiration(event)
        futurePeriod = expirationDate / periodLength
        if(expirationDate < block.timestamp):
            return(-7)
        forkPeriod = self.getForkPeriod(branch)
        if(forkPeriod && (futurePeriod == forkPeriod or futurePeriod == (forkPeriod+1) or futurePeriod == (forkPeriod+2))):
            return(-9)
        if(self.getEventBranch(event) != branch || !self.getCreator(event)):
            return(-1)
        if(expirationDate > tradingPeriod):
            tradingPeriod = expirationDate
        eventsConcat += event
        if(!self.getBond(event)):
            # pay validity bond
            period = block.timestamp / TWENTYFOURHR
            validity_bond =  (creationFee * (1 + self.getPast24(period)) / (1 + self.getNumberEvents(branch, self.getVotePeriod(branch))))/2
            if(!self.sendFrom(event, validity_bond, msg.sender)):
                return(-4)
            self.setBond(event, validity_bond)
            self.addPast24(period)
        #scalars
        maxValue = self.getMaxValue(event)
        minValue = self.getMinValue(event)
        if((maxValue!=TWO || minValue !=ONE) && self.getNumOutcomes(event)==2):
            # is a valid scalar
            cumulativeScale += maxValue - minValue
        eventNumOutcomes = self.getNumOutcomes(event)
        if(i==0):
            numOutcomes += eventNumOutcomes
        else:
            numOutcomes *= eventNumOutcomes
        i += 1
    if(numOutcomes > 8):
        return(-3)
    if(cumulativeScale==0):
        cumulativeScale = ONE
    tradingPeriod = (tradingPeriod / periodLength)

    # formation of marketID (hash)
    marketinfo = string(9*32 + len(description))
    marketinfo[0] = MARKET
    marketinfo[1] = msg.sender
    marketinfo[2] = branch
    marketinfo[3] = eventsConcat
    marketinfo[4] = len(events)
    marketinfo[5] = cumulativeScale
    marketinfo[6] = numOutcomes
    marketinfo[7] = tradingPeriod
    marketinfo[8] = tradingFee
    mcopy(marketinfo + 9*32, description, chars=len(description))
    marketID = sha256(marketinfo, chars=len(marketinfo))
    self.initiateOwner(marketID)
    # pay numOutcomes fee
    # if it's already been created return 0
    if(self.getCreator(marketID) || self.getMarketNumOutcomes(marketID)):
        return(-8)
    if(!self.getOracleOnly(branch) && self.balance(msg.sender) < creationFee):
        return(-4)
    # need at least 1.2M gas @ gas price to cover resolution + 1M for each additional event
    if(msg.value < (1200000*tx.gasprice + 1000000*tx.gasprice*(eventNum-1) + 500000*tx.gasprice)):
        return(0)
    if(self.sendFrom(branch, creationFee, msg.sender) && send(MARKETS, (msg.value-500000*tx.gasprice)) && self.setInfo(marketID, description, msg.sender, creationFee) && self.addMarketToBranch(branch, marketID) && self.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumulativeScale, numOutcomes, extraInfo, msg.value-500000*tx.gasprice, creationFee, block.number)):
        i = 0
        while i < len(events):
            self.addMarket(events[i], marketID)
            expirationDate = self.getExpiration(event)
            futurePeriod = expirationDate / periodLength
            self.addEvent(branch, futurePeriod, events[i], 500000*tx.gasprice)
            self.send(EVENTS, 500000*tx.gasprice)
            i += 1
        return(marketID)
    else:
        return(0)

def updateTradingFee(branch, market, tradingFee):
    refund()
    if(msg.sender != self.getCreator(market) || tx.origin != self.getCreator(market)):
        return(-4)
    oldFee = self.getTradingFee(market)
    oldCreationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / oldFee
    newCreationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / tradingFee
    if(tradingFee < self.getMinTradingFee(branch) or tradingFee > oldFee):
        return(-1)
    self.sendFrom(branch, newCreationFee-oldCreationFee, msg.sender)
    return(self.setTradingFee(market, tradingFee))

# Anyone can post an "Early Resolution Bond"
# This bond is equal to 0.5 * Market_Fee * Market_Value
# This amount is the amount needed to pay the reporters in case this was frivolous.
# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'
    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)
# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration dateevent
# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.
def pushMarketForward(branch, market):
    refund()
    branchEventIsInForked = 0
    winningForkDecided = 0
    if(branchEventIsInForked && !winningForkDecided):
        return(0)
    # if round 2 event don't allow it
    # prevent for backstop 1 markets and vice versa
    # todo: if has been pushed forward in the past (see close market) don't allow it again
    numEvents = self.getNumEvents(market)
    if(marketClosed):
        return(0)
    if(self.sendFrom(market, numEvents*self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*ONE), msg.sender)==0):
        return(0)
    i = 0
    # for each event in market
    while i < numEvents:
        if(1):
            #if(eventNotResolved && eventNotInRound2Adj && notRejectedBefore && event isn't already in next vote period):
            event = self.getMarketEvent(market, i)
            # push into next vote period
            period = self.getVotePeriod(branch)
            self.addEvent(branch, period+1, event)
            # set event expiration date to be after the current reporting period ends
            self.setExpiration(event, block.timestamp)
            self.setTradingPeriod(market, period+1)
            self.setPushedForward(market, 1, msg.sender)
        i += 1
    return(1)
inset('refund.se')

# buys amount of every outcome
# cost 850k gas
def buyCompleteSets(market, amount):
    refund()
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    numOutcomes = self.getMarketNumOutcomes(market)
    cumScale = self.getCumScale(market)
    cost = amount*cumScale/ONE
    if(self.balance(msg.sender) < cost):
        return(-3)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)
    i = 1
    # send shares of the event to user address
    while i <= numOutcomes:
        self.modifyShares(market, i, amount)
        self.modifyParticipantShares(market, participantNumber, i, amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), amount*cumScale/ONE)
    # send money from user acc. to market address/account
    self.sendFrom(market, cost, msg.sender)
    return(1)

    
# sells amount of every outcome [if user owns it]
def sellCompleteSets(market, amount):
    refund()
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    numOutcomes = self.getMarketNumOutcomes(market)
    cumScale = self.getCumScale(market)
    branch = self.getBranchID(market)
    if(self.getParticipantID(market, participantNumber) != msg.sender):
        return(-2)
    # these prices are in fixed point
    cost = amount*cumScale/ONE
    i = 1
    while i <= numOutcomes:
        if(self.getParticipantSharesPurchased(market, participantNumber, i) < amount):
            return(-3)
        i += 1
    i = 1
    while i <= numOutcomes:
        self.modifyShares(market, i, -amount)
        self.modifyParticipantShares(market, participantNumber, i, -amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, -amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), -amount*cumScale/ONE)
    # send funds from the market to the user acc.
    self.subtractCash(market, cost)
    self.addCash(msg.sender, cost)
    return(1)
inset('refund.se')

# sender/owner, then spender
data amountCanSpend[][]

event Transfer(_from:indexed, _to:indexed, _value)
event Approval(_owner:indexed, _spender:indexed, value)

# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
def sendReputation(branch, recver, value):
    refund()
    # Rep cannot be simultaneously spent (transferred) and used to vote
    currentVotePeriod = self.getVotePeriod(branch)
    # you can't trade if you or the person you're sending to have submitted a report, or at all in the second half of the period [b/c you can messup / cheat w/ reporting] and you can't trade in the first half of a period until you've been penalized for reporting wrongly/not reporting
    # use a diff. fun. than getReport here
    #if(value<=0 || self.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || self.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || self.getReport(branch, currentVotePeriod, recver, 0) != 0):
    # self.getReportedPeriod(branch, current)
    #    return(0)
    # need to check all this for the person it's being sent to as well
    #if(self.getRRUpToDate()!=1):
    #    doIt()
    #    self.RRDone = true
    #if(hasReported(lastPeriod) && periodOver && hasntcollectedfees && residual > periodLength/2):
    #    self.collectFees(lastPeriod)
    # before rep, after rep, balance
    # person you're sending to needs rr up to date / done as well
    # auto increment vote period if needed
    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one, only if in first half of period
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.initialPenalizedSetting(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractRep(branch, senderIndex, value) && self.addRep(branch, receiverIndex, value)):
            return(value)
        else:
            return(0)
    else:
        return(0)

# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
# sendDormantRep
def transfer(branch, recver, value):
    refund()
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0):
        return(0)

    sender = msg.sender
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=msg.sender):
        self.initialPenalizedSetting(branch, msg.sender, (self.getVotePeriod(branch)-1))
        self.addReporter(branch, sender)
        self.initialPenalizedSetting(branch, msg.sender, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            log(type=Transfer, msg.sender, recver, value)
            return(value)
        else:
            return(0)
    else:
        return(0)

# fails unless from has authorized sender
def transferFrom(branch, from, recver, value):
    refund()
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0):
        return(0)

    sender = from
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=from):
        self.initialPenalizedSetting(branch, from, (self.getVotePeriod(branch)-1))
        self.addReporter(branch, sender)
        self.initialPenalizedSetting(branch, from, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value && value > 0 && self.amountCanSpend[from][msg.sender]>=value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            self.amountCanSpend[from][msg.sender] -= value
            log(type=Transfer, from, recver, value)
            return(value)
        else:
            return(0)
    else:
        return(0)
    
# allows spender to withdraw from your account
def approve(branch, spender, value):
    self.amountCanSpend[msg.sender][spender] = value
    log(type=Approval, msg.sender, spender, value)
    return(1)

# returns amount spender can withdraw from owner
def allowance(owner, spender):
    return(self.amountCanSpend[owner][spender])

# error messages
    # -1: not in first half of reporting period
# shouldn't be penalized for dormant rep when converting back to active due to not reporting beyond the dormant penalization
def convertToDormantRep(branch, value):
    refund()
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
      return(-1)
		# benny comment:
            #```Maybe still have this sort-of variable "power" to it, but REP initially doesn't have "full-power", or REP that hasn't been used to report over the past week has now let it's "power-meter" drop to only 20% earning power (it's kind-of dormant), that then ramps back up to 100% power once it gets used a bit. Could there be an element of this type of time-decay programmed into the REP that's helps incentive? Something like this would make the system more automatic, rather than relying on the user to manually switch "on" or switch "off" the self. If a user knows, "I better report this week or my REP's power meter goes down to 20% again, and it's gonna take extra effort to get it back to full-power", well that's pretty good incentive to keep the user active, without actually taking it from them.```

    if(value<=0):
        return(0)

    #if(self.getRRUpToDate()!=1):
    #    doIt()

    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.initialPenalizedSetting(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value):
        if(self.subtractRep(branch, senderIndex, value) && self.addDormantRep(branch, senderIndex, value)):
            self.adjustActiveRep(branch, -value)
            return(value)
        else:
            return(0)
    else:
        return(0)

# error messages
    # -1: not in first half of reporting period
def convertToActiveRep(branch, value):
    refund()
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
      return(-1)

    if(value<=0):
        return(0)

    #if(self.getRRUpToDate()):
        #doIt()
    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.initialPenalizedSetting(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addRep(branch, senderIndex, value)):
            self.adjustActiveRep(branch, value)
            return(value)
        else:
            return(0)
    else:
        return(0)
inset('refund.se')

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

def catch(x):
    refund()
    return(catch(x))

## helper functions:
macro closeOut($event, $market, $branch, $votingPeriodEvent, $fxpOutcome, $periodLength, $ethical, $scalar, $sender):
    # In the $event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and $market remains with old expiration date
    indeterminate = ONEHALF*3
    if($scalar):
        indeterminate = ONEHALF
    if($fxpOutcome == indeterminate && self.getPushedForward($market)):
        #set $event expiration to be the old date prior to this bond process
        self.setExpiration($event, self.getOriginalExpiration($event))
        self.setTradingPeriod($market, self.getOriginalTradingPeriod($market))
        self.addCash($branch, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
        self.subtractCash($market, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
        self.setPushedForward($market, 0, $sender)
        self.setNumReportsExpectedEvent($branch, $votingPeriodEvent, $event, 0)
        self.setNumReportsEvent($branch, $votingPeriodEvent, $event, 0)
        #set outcome to 0
        self.setOutcome($event, 0)
        self.setmode($event, 0)
        self.setEthics($event, 0)
        #set uncaughtoutcome to 0
        self.setUncaughtOutcome($event, 0)
        # need to store uncaught outcome for rejectedperiod separately as well as which period it was "rejected" in
        self.setRejected($event, self.getExpiration($event)/$periodLength, $fxpOutcome)
        return(-6)
    elif($fxpOutcome==indeterminate || !$ethical):
        # give $event bond money to reporters
        self.subtractCash($event, self.getBond($event))
        self.addCash($branch, self.getBond($event))
        # not $ethical is same as .5 outcome
        $fxpOutcome = indeterminate
        self.setOutcome($event, $fxpOutcome)
    else:
        # return bond
        self.subtractCash($event, self.getBond($event))
        self.addCash(self.getCreator($event), self.getBond($event))
        if(self.getPushedForward($market)):
            self.addCash(self.getBondsMan($market), self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
            self.subtractCash($market, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
            # delete old $event from future events exp
            self.removeEvent($branch, self.getOriginalExpiration($event)/$periodLength)

def resolveBinary(event, market, branch, votingPeriodEvent, sender):
    refund()
    fxpOutcome = catch(self.getUncaughtOutcome(event))
    periodLength = self.getPeriodLength(branch)
    ethical = ethic_catch(self.getEthical(event))
    self.setOutcome(event, fxpOutcome)
    self.setEthics(event, ethical)
    closeOut(event, market, branch, votingPeriodEvent, fxpOutcome,  periodLength, ethical, 0, sender)
    return(1)
    
def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent, sender):
    refund()
    mode = self.getUncaughtOutcome(event)
    self.setmode(event, mode)
    fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
    self.setOutcome(event, fxpOutcome)
    periodLength = self.getPeriodLength(branch)
    ethical = ethic_catch(self.getEthical(event))
    self.setEthics(event, ethical)
    closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 1, sender)
    return(1)

def determineWinningOutcomes(events: arr, numberEvents, branch, market):
    refund()
    n = 0
    winningOutcomes = array(8)
    while n < numberEvents:
        fxpOutcome = self.getOutcome(events[n])
        outcome = fxpOutcome/ONE
        indeterminate = ONEHALF*3
        if(scalar(events[n])):
            indeterminate = ONEHALF
        if(n==0):
            #scalar or .5
            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):
                winningOutcomes[0] = 1
                winningOutcomes[1] = 2
            # anything besides scalar or .5
            else:
                winningOutcomes[0] += outcome
        elif(n==1):
            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):
                # scalar, scalar
                if(winningOutcomes[1]):
                    winningOutcomes[2] = 3
                    winningOutcomes[3] = 4
                # nonscalar, scalar
                else:
                    #winningOutcomes[0] = winningOutcomes[0]
                    winningOutcomes[1] = winningOutcomes[0] + self.getNumOutcomes(events[n-1])
            # scalar, nonscalar
            elif(winningOutcomes[1]):
                winningOutcomes[0] += self.getNumOutcomes(events[n-1])*(outcome-1)
                winningOutcomes[1] += self.getNumOutcomes(events[n-1])*(outcome-1)
            # nonscalar, nonscalar
            else:
                winningOutcomes[0] += self.getNumOutcomes(events[n-1])*(outcome-1)
        elif(n==2):
            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):
                #scalar, scalar, scalar
                if(winningOutcomes[3]):
                    winningOutcomes[4] = 5
                    winningOutcomes[5] = 6
                    winningOutcomes[6] = 7
                    winningOutcomes[7] = 8
                #scalar, nonscalar, scalar
                #nonscalar, scalar, scalar
                elif(winningOutcomes[1]):
                    #winningOutcomes[0] = winningOutcomes[0]
                    #winningOutcomes[1] = winningOutcomes[1]
                    winningOutcomes[2] += winningOutcomes[0] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
                    winningOutcomes[3] += winningOutcomes[1] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
                #nonscalar, nonscalar, scalar
                elif(winningOutcomes[1]==0):
                    #winningOutcomes[0] = winningOutcomes[0]
                    winningOutcomes[1] += winningOutcomes[0] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
            else:
                #scalar, scalar, nonscalar
                if(winningOutcomes[3]):
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[1] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[2] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[3] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                #scalar, nonscalar, nonscalar
                #nonscalar, scalar, nonscalar
                elif(winningOutcomes[1]):
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[1] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                #nonscalar, nonscalar, nonscalar
                else:
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
        n+=1
    return(winningOutcomes: arr)
inset('refund.se')


# Appeal_Bond = Market_Value * (0.01 + Market_Fee / 2) + Average_Adjudication_Cost
    # Average_Adjudication_Cost = Total fees paid to reporters for all markets in this reporting round / number of markets in this reporting round.
        # needs an abs min of ~200 rep.
# Reporting period is 2 months minus 48 hours.  This 48 hours allows for the appeals to take place before the next reporting round begins.
def roundTwoPostBond(branch, event, eventIndex, votePeriod):
    refund()
    if(self.getVotePeriod(branch)!=votePeriod):
        return(0)
    market = self.getMarket(event, 0)
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod == votePeriod or (forkPeriod+1) == votePeriod or (forkPeriod+2) == votePeriod):
        return(0)
    avgAdjCost = self.getInitialBalance(branch, votePeriod)/self.getNumberEvents(branch, votePeriod)
    bond = avgAdjCost + self.getSharesValue(market)*(184467440737095520 + self.getTradingFee(market)/2) / 2**64
    bond = min(bond, 200*ONE)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    # if so, we're in the final 24 hours and event is in this branch + votePeriod
    if(!resolving && block.timestamp/self.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/self.getPeriodLength(branch)) && eventID!=0 && event==eventID && self.getRoundTwo(event)==0 && self.getForked(event)==0):
        if(self.sendReputation(branch, event, bond)==0):
            return(0)
        period = self.getVotePeriod(branch)
        # remove from events in # to report on calc for last period
        self.removeEvent(branch, period)
        # makes event required reporting in round 2 (the next period) as well
        self.setEventRequired(branch, period+1, event)
        # push event into next period
        self.addEvent(branch, period+1, event)
        # set event expiration date to be after the current reporting period ends
        self.setExpiration(event, block.timestamp)
        # set round two to true so can't be done again
        self.setRoundTwo(event, 1)
        self.setOriginalVotePeriod(event, votePeriod)
        if(scalar(event) or categorical(event)):
            self.setOriginalOutcome(event, self.getUncaughtOutcome(event))
        else:
            self.setOriginalOutcome(event, catch(self.getUncaughtOutcome(event)))
        self.setOriginalEthicality(event, ethic_catch(self.getEthical(event)))
        self.addRoundTwo(branch, period)
        self.setBondPoster(event, msg.sender)
        self.setUncaughtOutcome(event, 0)
        self.setmode(event, 0)
        self.setEthics(event, 0)
        return(1)
        self.setUncaughtOutcome(event, 0)
        self.setmode(event, 0)
        self.setEthics(event, 0)
        return(1)

def roundTwoResolve(branch, event, eventIndex):
    refund()
    overruled = 1
    bond = 100*ONE
    votedOnAgain = 0
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(scalar(event) or categorical(event)):
        if(self.getOriginalOutcome(event) == self.getUncaughtOutcome(event) && self.getOriginalEthicality(event)==ethic_catch(self.getEthical(event))):
            overruled = 0
    elif(self.getOriginalOutcome(event) == catch(self.getUncaughtOutcome(event)) && self.getOriginalEthicality(event)==ethic_catch(self.getEthical(event))):
        overruled = 0
    votePeriod = self.getVotePeriod(branch)
    if(votePeriod > (self.getExpiration(event) / self.getPeriodLength(branch))):
        votedOnAgain = 1
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod==votePeriod or votePeriod==(forkPeriod+1) or votePeriod==(forkPeriod+2) && (self.getEventForkedOver(branch)!=event && self.getBondReturned(event)==0 && self.getRoundTwo(event))):
        # return the bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        self.setBondReturned(event)
        self.setRoundTwo(event, 0)
        return(1)
    elif(overruled && votedOnAgain && self.getRoundTwo(event) && votePeriod!=self.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && msg.sender == bondPoster && !self.getBondReturned(event)):
        # return the bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        # and set final outcome / event bond, etc
        self.resolve(branch, event, msg.sender)
        # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, then beyond that the people who originally reported whatever the actual truth was would get the rest. then regular rbcr for the round 2 reporting [don't count ethicality here]
        self.setFinal(event)
        self.setBondReturned(event)
        return(2*bond)
    elif(votedOnAgain && self.getRoundTwo(event) && votePeriod!=self.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !self.getBondReturned(event)):
        # lose bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, branch), bond)
        # and set final outcome / event bond, etc
        self.resolve(branch, event, msg.sender)
        # rbcr from original period/orig. outcome stands, rbcr from round 2 happens as usual as well
        self.setFinal(event)
        self.setBondReturned(event)
    # not voted on again yet
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==2**6Z)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)
    
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

# take from bond to pay for resolution of a round 2 event
def resolve(branch, event, sender):
    refund()
    bond = self.getBond(event)
    ethical = ethic_catch(self.getEthical(event))
    payback = min(1000000*tx.gasprice*ONE/WEITOETH, bond)
    # binary
    if(binary(event)):
        fxpOutcome = catch(self.getUncaughtOutcome(event))
        self.setOutcome(event, fxpOutcome)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond-payback)
            self.addCash(sender, payback)
            # not ethical is same as 1.5 outcome w/ binary
            fxpOutcome = 3*ONEHALF
            self.setOutcome(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(sender, payback)
            self.addCash(self.getCreator(event), bond-payback)
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = self.getUncaughtOutcome(event)
        self.setmode(event, mode)
        scaled_max = self.getMaxValue(event)
        scaled_min = self.getMinValue(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        self.setOutcome(event, fxpOutcome)
        if(fxpOutcome==ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond-payback)
            self.addCash(sender, payback)
            # not ethical is same as .5 outcome w/ scalar
            fxpOutcome = ONEHALF
            self.setOutcome(event, fxpOutcome)
            self.setmode(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(sender, payback)
            self.addCash(self.getCreator(event), bond-payback)
        return(1)
    # (should never be reached)
    else:
        return(0)
inset('refund.se')


# todo move to consensus data_api and backstops for round 2
# round two consensus data [note/todo: UI should show round 2 events first / up top]
data bondPaid[]
data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, final)
data baseReportersLastPeriod[]

event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)


# todo: make it 0.98 * old rep + 0.02 * new rep
# (1-k) * old rep + k * new rep where k = 0.2 / (number of events you reported on last period)


# branch takes a branchID
    # denominator takes a vote period
    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total
    # penalizedUpTo is the latest period a user has done the penalization for
    # fees collected states whether for a given period a user collected fees
    # rep collected states whether for a given period a user collected rep
data branch[](denominator[], penalized[][](event[], num, notEnoughReportsPenalized), penalizedUpTo[], feesCollected[][])

def getFeesCollected(branch, address, period):
    return(self.branch[branch].feesCollected[period][address])

def setFeesCollected(branch, address, period):
    self.branch[branch].feesCollected[period][address] = 1
    return(1)

def setNotEnoughPenalized(branch, address, period):
    self.branch[branch].penalized[period][address].notEnoughReportsPenalized = 1
    return(1)
    
def getNotEnoughPenalized(branch, address, period):
    return(self.branch[branch].penalized[period][address].notEnoughReportsPenalized)
    
def getBaseReportersLastPeriod(branch):
    return(self.baseReportersLastPeriod[branch])

def initialPenalizedSetting(branch, reporter, upto):
    refund()
    self.branch[branch].penalizedUpTo[reporter] = upto
    return(1)
    
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

#1. Record rep at start of report period [before rep in make reports]
#2. Penalize for each event
#3. Each reporter needs to do this for all events they reported on, if not get docked
#4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees
#5. If you don't do it for all events or don't penalize for not reporting enough, autolose 20% rep each period one does this (b/c they're trying to cheat)
# Errors:
    # -1: pushed forward event already resolved, so can't redistribute rep based off of its original expected expiration period
    # -2: already past first half of new period and needed to penalize before then
    # -3: need to do not enough reports penalization [or lackthereof]
# roundTwoResolve needs to be called for any event here before can be penalized if it's a backstop 1 event, a la close market for other events before being penalized
# always use uncaught + caught version as opposed to actual outcome for this to be safe wrt ethicality / diff. for payouts
# make max rep loss 20%, do V way to limit excess cuts
def penalizeWrong(branch, event):
    refund()
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    afterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    if(self.getForkPeriod(branch) == lastPeriod && penalizedForkedEventIfReportedOn && !penalizeduptolastperiod):
        self.branch[branch].penalized[lastPeriod][msg.sender].num += self.getNumReportsActual(branch, lastPeriod, msg.sender)
        self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod
        self.branch[branch].denominator[lastPeriod] += afterRep
        return(1)
    elif(self.getForkPeriod(branch) == lastPeriod):
        return(-10)
    if(self.getForkPeriod(branch)+1 == lastPeriod && !penalizeduptolastperiod):
        self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod
        self.branch[branch].denominator[lastPeriod] += afterRep
        return(1)
    elif(self.getForkPeriod(branch)+1 == lastPeriod):
        return(-11)
    if(self.getForked(event)):
        return(0)
    if(!self.branch[branch].penalized[lastPeriod][msg.sender].notEnoughReportsPenalized):
        return(-3)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        return(-2)
    # accounts for if no events in a period
    if(self.getNumberEvents(branch, lastPeriod)==0):
        self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod
        self.branch[branch].denominator[lastPeriod] += afterRep
        return(1)

    if(self.getOriginalExpiration(event)!=self.getExpiration(event) && self.getPushedForward(market)):
        if(lastPeriod==self.getOriginalExpiration(event)/self.getPeriodLength(branch)):
            return(-1)

    newRep = 0
    outcome = catch(self.getUncaughtOutcome(event))
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    p = self.proportionCorrect(event)
    if(scalar(event) or categorical(event)):
        outcome = self.getUncaughtOutcome(event)
    
    # for a reporter for last period if they reported on it the first time [a round 2 event], prevent them from reporting on it, but still do the rep redistrib. at the end before returning in case this event is the last one a user submits for reporting and increment the num b/c it shouldn't be penalized until the next period resolution is over
    if(self.getRoundTwo(event) && !self.branch[branch].penalized[lastPeriod][msg.sender].event[event] && reportValue && outcome!=0):
        self.branch[branch].penalized[lastPeriod][msg.sender].event[event] = 1
        self.branch[branch].penalized[lastPeriod][msg.sender].num += 1
        if(self.getNumReportsActual(branch, lastPeriod, msg.sender)==self.branch[branch].penalized[lastPeriod][msg.sender].num):
            newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
            if(newAfterRep <= 0):
                newAfterRep = 0
                self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod
            self.branch[branch].denominator[lastPeriod] += newAfterRep
            totalRepDifference = newAfterRep - oldRep
            if(repBalance + totalRepDifference <= 0):
                totalRepDifference = -1*repBalance
            if(totalRepDifference<0):
                # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
                # sends that rep to the branch
                self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    if(!self.branch[branch].penalized[lastPeriod][msg.sender].event[event] && reportValue && (outcome!=0 or self.getRejected(event))):
        if(self.getRejectedPeriod(event)==lastPeriod):
            outcome = ONEHALF*3
            mode = ONEHALF*3
        # wrong
        #184467440737095520 == 0.01 in fxp
        if(reportValue > outcome+184467440737095520 or reportValue < outcome-184467440737095520):
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                # makes it so 1.5 penalty isn't super harsh for a scalar / categorical
                if(outcome == 3*ONEHALF && (scalar(event) or categorical(event))):
                    reportValue += ONE
                diff = reportValue - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*p - ONE)/ONE
        # right
        else:
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                # makes it so 1.5 penalty isn't super harsh for a scalar / categorical
                if(outcome == 3*ONEHALF && (scalar(event) or categorical(event))):
                    reportValue += ONE
                diff = reportValue - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
        #smoothedRep = oldRep*.8 + newRep*.2
        smoothedRep = oldRep * 14757395258967642112/ONE + newRep * 3689348814741910528/ONE
        repChange = smoothedRep - oldRep
        newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        log(type=penalize, msg.sender, outcome, oldRep, repChange, newAfterRep, p, reportValue)
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        self.branch[branch].penalized[lastPeriod][msg.sender].event[event] = 1
        self.branch[branch].penalized[lastPeriod][msg.sender].num += 1
        if(self.getNumReportsActual(branch, lastPeriod, msg.sender)==self.branch[branch].penalized[lastPeriod][msg.sender].num):
            if(newAfterRep <= 0):
                newAfterRep = 0
                self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod
            self.branch[branch].denominator[lastPeriod] += newAfterRep
            totalRepDifference = newAfterRep - oldRep
            if(repBalance + totalRepDifference <= 0):
                totalRepDifference = -1*repBalance
            if(totalRepDifference<0):
                # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
                # sends that rep to the branch
                self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)

def getDenominator(branch, period):
    refund()
    return(self.branch[branch].denominator[period])

# call when a user who hasn't reported for a while wants to start again and needs to catch up on penalizations
# ex:
    #period 0 voteperiod -1 - last period penalized should be -1 or starting vote period
    #add some events to period 0
    #increment
    #period 1 voteperiod 0 - shouldn't be penalizing anything yet
    #increment
    #period 2 voteperiod 1 - penalize voteperiod 0
# ex 2:
    #currently in period 100, voteperiod 99 - last period penalized up to should be 99 or starting vote period
    #add some events to period 100
    #increment to period 101
    #period 101, voteperiod 100 - shouldn't be penalizing anything yet
    #increment
    #period 102, voteperiod 101 - penalize voteperiod 100
def penalizationCatchup(branch):
    refund()
    # should only be allowed in 1st half of any period b/c rep removal / sending to branch should only be done then
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        return(-2)
    # find delta between this last period and last penalized up to
    lastPeriodPenalized = self.branch[branch].penalizedUpTo[msg.sender]
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    oldRep = self.getRepBalance(branch, msg.sender)
    if(lastPeriodPenalized!=lastPeriod && !hasReported(branch, lastPeriod)):
        if(delta <= 0):
            return(0)
        # dock 10% for each period they didn't penalize on
        #smoothedRep = oldRep*16602069666338596864/ONE
        smoothedRep = oldRep*18262276632972455936/ONE 
        i = 1
        if(delta>22):
            #smoothedRep = smoothedRep*1844674407370955264/ONE
            smoothedRep = smoothedRep*18262276632972455936/ONE
            delta = 22
        while i < delta:
            #smoothedRep = smoothedRep*16602069666338596864/ONE
            smoothedRep = smoothedRep*18262276632972455936/ONE
            i += 1
        # and send it to branch for penalty rep collection
        repChange = oldRep - smoothedRep
        # removes rep from reporter who lost it
        self.subtractRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), repChange)
        self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod
        return(1)
    else:
        return(0)

# ui has to call this to stay cheap / not check it elsewhere
def incrementPeriodAfterReporting(branch):
    refund()
    # do this after reporting is finished
    if(periodOver(branch)):
        period = block.timestamp / self.getPeriodLength($branch) - 1
        lastPeriod = period - 1
        percentAppealed = (self.getNumRoundTwo(branch, period)*ONE/self.getNumberEvents(branch, period) + self.getNumRoundTwo(branch, lastPeriod)*ONE/self.getNumberEvents(branch, lastPeriod)) / 2
        self.incrementPeriod(branch)
        # mult. by 2 b/c reporters only have to report on half the things they're selected to report on
        base_reporter_quantity = 2*(3*ONE + ((333*ONE * Percent_Appealed/ONE)**3 / 2**128))/ONE
        self.baseReportersLastPeriod[branch] = self.getBaseReporters(branch)
        self.setBaseReporters(branch, base_reporter_quantity)
        return(1)
    else:
        return(0)
        
### Helper functions:

macro abs($a):
    if($a<0):
        $a = -$a
    $a

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

def proportionCorrect(event):
    refund()
    p = 0
    outcome = catch(self.getUncaughtOutcome(event))
    if(outcome!=0):
        # binary
        if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
            # subtract 1 to get it from 0 to 1
            avgOutcome = self.getUncaughtOutcome(event) - ONE
            # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
            if(outcome == ONE):
                p = ONE - avgOutcome
            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
            if(outcome == 2 * ONE):
                p = avgOutcome
            if(outcome == 3 * ONEHALF):
                return(0)
        return(p)
    else:
        return(0)

macro periodOver($branch):
    # what the current vote period should be
    currentVotePeriod = block.timestamp / self.getPeriodLength($branch) - 1
    # if actual vote period is less than what the current one should be, return 1, it can be incremented
    if(self.getVotePeriod($branch) < currentVotePeriod):
        1
    else:
        0
    
macro hasReported($branch, $period):
    self.getReportedPeriod($branch, $period, msg.sender)

macro repRedistributionDone($branch, $reporter):
    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]
    lastPeriod = self.getVotePeriod($branch)-1
    if(lastPeriod==lastPeriodPenalized):
        1
    else:
        0

def getRRDone(branch, reporter):
    refund()
    return(repRedistributionDone(branch, reporter))


macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)

inset('refund.se')

data slashed[][]

# anti cheat provide ballot and randomNum mechanism steal deposit
# Returns:
    # 0: not a valid claim
    # -2: reporter doesn't exist
def slashRep(branch, salt, report, reporter, eventID, testing):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        return(-2)
    votePeriod = self.getVotePeriod(branch)
    # if actually past vote period dont allow it
    if(!testing):
        votePeriodShouldBe = block.timestamp / periodLength - 1
        if(votePeriodShouldBe!=votePeriod):
            return(0)
    realHash = self.getReportHash(branch, votePeriod, reporter, eventID)
    hashInfo = array(4)
    hashInfo[0] = reporter
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha256(hashInfo, chars=32*len(hashInfo))
    if(reportHash!=realHash):
        return(0)
    else:
        if(!self.slashed[votePeriod][reporter]):
            reporterIndex = self.repIDToIndex(branch, reporter)
            trutherIndex = self.repIDToIndex(branch, msg.sender)
            # if the truther's rep. account doesn't exist, make one
            if(self.getReporterID(branch, trutherIndex)!=msg.sender):
                trutherIndex = self.getNumberReporters(branch)
                self.addReporter(branch, msg.sender)
            if(self.getReporterID(branch, reporterIndex)!=reporter):
                return(-2)
            reporterBalance = self.getRepBalance(branch, reporter)
            self.setRep(branch, reporterIndex, 0)
            trutherBalance = self.getRepBalance(branch, msg.sender)
            self.setRep(branch, trutherIndex, (trutherBalance + reporterBalance*ONEHALF / ONE))
            self.slashed[votePeriod][reporter] = 1
        else:
            return(0)
    return(reporterBalance)
inset('refund.se')


#Notes:
    #Anyone can pay some amount significantly greater than the bond amount to force a branching event, splitting rep into two classes.  
    #In one class the reported outcome for whatever event was the cause of dispute is said to be right, and rep is redistributed accordingly.  
    #In the other class/branch, the event is readjudicated and remove the outcome on the pre fork branch and rep is redistributed as normal, except people who said the original outcome in the original fork lose rep.  
    # Note: Whichever outcome was truly the correct one would determine which branch had rep that actually held value.  This would be akin to a Bitcoin hard fork scenario.  The winning fork, of course, would be the one with the most voluminous markets, which would be determined by the fork that represented reality, which would have a higher market cap.  Markets go to the most popular fork by default after 2 months.

# todo move to backstops data_api
# branch and forkperiod and who won
data forkResolved[][]
data eventMoved[]
data forkData[](originalBranch)
data forking[](bondPoster)
data bondPaid[]
data forkedOverEthicality[]
data bondAmount[]

def getForkBondPoster(event):
    return(self.forking[event].bondPoster)

def getForkedOverEthicality(event):
    return(self.forkedOverEthicality[event])
    
def getBondPaid(event):
    return(self.bondPaid[event])

def getBondAmount(event):
    return(self.bondAmount[event])



# Period where we forked, at the end of it
    # don't penalize for this period / anything that happened here should be considered to not have happened - done
    # let period be incremented as normal - done
    # no rbcr on this period besides for event forked over on original. parent but don't actually resolve the event until later per below - done
    # fork users get a free pass for not reporting on this period - done
# Period after fork where we need to do nothing while waiting for fork to resolve
    # free pass for not reporting during this period in og branch - done
    # no reporting or rbcr in this period except for on fork branch we re-report on the forked market and that's it, so no free pass on fork for that one event - done
# Period after fork is resolved
    # markets can't be moved until now - done
    # all markets have early exp disabled until this point - done
    # each event which should've resolved in the past 2 periods and this one is pushed up into period after this - done
        # stays in parent if it wins, otherwise goes to new fork - done
    # each event resolving further in the future is pushed into the respective period on whichever fork wins - done
def move_event(event):
    forkPeriod = self.getForkPeriod(self.getEventBranch(event))
    branch = self.getEventBranch(event)
    eventForkedOver = self.getEventForkedOver(branch)
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    if(forkPeriod && currentPeriod == (forkPeriod+2) && !self.getOutcome(event) && !self.eventMoved[event]):
        winner = self.forkResolved[branch][forkPeriod]
        if(winner==0):
            winner = self.resolve_fork(branch)
        self.setBranch(event, winner)
        self.eventMoved[event] = 1
        if(event == eventForkedOver):
            return(1)
        elif(winner == self.getEventBranch(event)):
            # set outcomes to 0
            self.setOutcome(event, 0)
            self.setmode(event, 0)
            self.setEthics(event, 0)
            self.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            self.roundTwoResolve(branch, event, eventIndex)
            
            # leave event here
            expPeriod = self.getExpiration(event)/self.getPeriodLength(branch)
            # if should've resolved in past periods
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1) or expPeriod == (forkPeriod+2)):
                # push it into next [this] period
                self.addEvent(branch, currentPeriod+1, eventID)
                self.setExpiration(event, block.timestamp)
            # otherwise it's set to expire in the period it would've expired in as normal, no changes needed
        else:
            # set outcomes to 0
            self.setOutcome(event, 0)
            self.setmode(event, 0)
            self.setEthics(event, 0)
            self.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            self.roundTwoResolve(branch, event, eventIndex)

            # move event to fork
            expPeriod = self.getExpiration(event)/self.getPeriodLength(branch)
            # and place it into the next reporting period w/ outcomes to 0
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1) or expPeriod == (forkPeriod+2)):
                # push it into next [this] period
                self.addEvent(branch, currentPeriod+1, eventID)
                self.setExpiration(event, block.timestamp)
            else:
                # push into period it wouldve expired in
                self.addEvent(branch, expPeriod, eventID)
                # expiration time doesnt need to change
    else:
        return(0)

# parent branch is branch here
def resolve_fork(branch):
    forkPeriod = self.getForkPeriod(self.getEventBranch(event))
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    # make sure branch forked
    if(currentPeriod != (forkPeriod+2)):
        return(0)
    origCap = self.exchangeRate(branch)
    fork = self.getFork(branch)
    forkCap = self.exchangeRate(fork)
    if(origcap >= forkCap):
        winner = branch
        self.setWinner(branch, winner)
        return(winner)
    else:
        winner = fork
        self.setWinner(branch, winner)
        return(winner)
    
def setWinner(branch, winner):
    self.forkResolved[branch][winner] = winner
    return(1)

#Resolve fork method that gets exchange rate
def exchangeRate(branch):
    # get rep exchange rate from etherex for (branch)
    #return(exchangeRate)
    # for testing we'll just rng the exchange rate :)
    return(sha256(branch))

# In the last 48 hours during period where a round 2 was pushed back to, can be made to fork instead of just round 2, so round 2 bond poster gets bond back
# bond is 1% of rep
# todo make it so can only push back in last 48 hr of _second_ period
# todo pay back bond poster
# todo fork over ethicality or outcome
# round 2 penalize consensus don't pay back reporter b/c bond already returned.. on orig. branch
# todo make sure branch isn't forking when we make a fork...
def fork(event, branch, forkedOverEthicality):
    if(!self.getRoundTwo(event) || self.getFinal(event) || self.getForked(event)):
        return(-1)
    if(self.getBranch(event)!=branch):
        return(0)
    # if in last 48 hr of period
    if(block.timestamp/self.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/self.getPeriodLength(branch)) && self.getUncaughtOutcome(event)!=0 && !self.getForked(event)):
        bond = 184467440737095520*self.getTotalRep(branch)/ONE
        self.bondAmount[branch] = bond
        # lose fork bond in branch 1
        # results same as roundtwobond, let it resolve as that on original network
        if(self.sendReputation(branch, event, bond)==0):
            return(-2)

        # on branch 2 fork bond isn't lost
        # on fork bond isn't lost, gets paid up to 2x from "liars"
        # make the fork
        newBranch = self.createSubbranch(text("fork"), self.getPeriodLength(branch), branch, self.getMinTradingFee(branch), 0)
        self.setFork(newBranch)
        period = self.getVotePeriod(newBranch)
        self.setEventRequired(newBranch, period+1, event)
        self.addEvent(newBranch, period+1, event)
        self.setExpiration(event, block.timestamp)
        self.forkData[event].originalBranch = branch
        self.forking[event].bondPoster = msg.sender
        self.setForked(event)
        self.setFinal(event)
        self.roundTwo[event].final
        self.setForkPeriod(branch)
        self.setForkPeriod(newBranch)
        self.setEventForkedOver(newBranch, event)
        self.setEventForkedOver(branch, event)
        self.forkedOverEthicality[event] = forkedOverEthicality
        # return round 2 bond
        market = self.getMarket(event, 0)
        avgAdjCost = self.getInitialBalance(branch, period-1)/self.getNumberEvents(branch, votePeriod-1)
        bond = avgAdjCost + self.getSharesValue(market)*(184467440737095520 + self.getTradingFee(market)/2) / 2**64
        bond = min(bond, 200*ONE)
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.roundTwo[event].bondPoster), bond)
    else:
        return(0)


# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
# branch is orig. branch
# market creator pay for or bond person pay for?
def resolveForkedEvent(branch, event, votePeriod):
    refund()
    bond = 100*ONE
    votedOnAgain = 0
    if(self.getBranch(event)!=branch):
        return(0)
    if(self.getVotePeriod(branch) > (self.getExpiration(event) / self.getPeriodLength(branch))):
        votedOnAgain = 1
    if(!self.getForked(event)):
        return(-1)
    if(self.resolveForkEvent(branch, event)):
        self.setForkDone(event)
    # fork not done yet
    else:
        return(0)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
def resolveForkEvent(branch, event):
    refund()
    winner = self.forkResolved[branch][forkPeriod]
    if(!winner):
        return(-5)
    
    # binary
    if(binary(event)):
        fxpOutcome = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            fxpOutcome = catch(self.getUncaughtOutcome(event))
            ethical = ethic_catch(self.getEthical(event))
        # fork won
        else:
            fxpOutcome = catch(self.getForkOutcome(event))
            ethical = ethic_catch(self.getForkEthicality(event))
        
        self.setOutcome(event, fxpOutcome)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, self.getBond(event))
            self.addCash(branch, self.getBond(event))
            # not ethical is same as .5 outcome
            fxpOutcome = 3*ONEHALF
            self.setOutcome(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, self.getBond(event))
            self.addCash(self.getCreator(event), self.getBond(event))
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            mode = self.getUncaughtOutcome(event)
            ethical = ethic_catch(self.getEthical(event))
        # fork won
        else:
            mode = self.getForkOutcome(event)
            ethical = ethic_catch(self.getForkEthicality(event))

        self.setmode(event, mode)
        scaled_max = self.getMaxValue(event)
        scaled_min = self.getMinValue(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        self.setOutcome(event, fxpOutcome)

        if(fxpOutcome==ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, self.getBond(event))
            self.addCash(branch, self.getBond(event))
            # not ethical is same as .5 outcome
            fxpOutcome = ONEHALF
            self.setOutcome(event, fxpOutcome)
            self.setmode(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, self.getBond(event))
            self.addCash(self.getCreator(event), self.getBond(event))
        return(1)
    # (should never be reached)
    else:
        return(0)


# rbcr is done as a normal event where everyone reports on it
# only called on the fork not the parent, normal penalization except the values are forkOutcome and forkEthicality as opposed to anything else
# some rep from this goes to bond poster, original / last period report is actually what a user reported on the parent for the round 2 bond vote, they lose rep as well as people this time who report wrong
# branch is fork
def penalizeOnForkedEvent(branch, event):
    if(self.getForked(event)==0):
        return(-1)
    # means event / fork isn't resolved
    if(self.getForkedDone(event)==0):
        return(-2)
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    if(!self.branch[branch].penalized[lastPeriod][msg.sender].notEnoughReportsPenalized):
        return(-3)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        return(-2)
    if(self.getOriginalExpiration(event)!=self.getExpiration(event) && self.getPushedForward(market)):
        if(lastPeriod==self.getOriginalExpiration(event)/self.getPeriodLength(branch)):
            return(-1)

    newRep = 0
    newAfterRep = 0
    smoothedRep = 0
    totalRepDifference = 0
    outcome = catch(self.getForkOutcome(event))
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    lastPenalizationPeriod = lastPeriod - 1
    oldReport = self.getReport(self.getParent(branch), lastPenalizationPeriod, msg.sender)
    p = self.proportionCorrectForkEvent(event)
    if(scalar(event) or categorical(event)):
        outcome = self.getForkOutcome(event)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)

    # Do the first rbcr based on first report and final outcome if reported first time
    if(oldReport && !self.branch[branch].penalized[lastPeriod][msg.sender].event[event] && outcome!=0):
        oldEthics = self.getEthicReport(self.getParent(branch), lastPenalizationPeriod, event, msg.sender)
        # wrong
        #184467440737095520 == 0.01 in fxp
        if(oldReport > outcome+184467440737095520 or oldReport < outcome-184467440737095520):
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                # makes it so 1.5 penalty isn't super harsh for a scalar / categorical
                if(outcome == 3*ONEHALF && (scalar(event) or categorical(event))):
                    oldReport += ONE
                diff = oldReport - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*p - ONE)/ONE
        # right
        else:
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                # makes it so 1.5 penalty isn't super harsh for a scalar / categorical
                if(outcome == 3*ONEHALF && (scalar(event) or categorical(event))):
                    oldReport += ONE
                diff = oldReport - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
        #smoothedRep = oldRep*.8 + newRep*.2
        smoothedRep = oldRep * 14757395258967642112/ONE + newRep * 3689348814741910528/ONE
        repChange = smoothedRep - oldRep
        newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        totalRepDifference = repChange
        # for ethicality if diff. appeal then pay back the fork bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
        if(oldEthics != ethic_catch(self.getEthical(event)) && totalRepDifference >=0):
            totalRepDifference = -184467440737095520*repBalance / ONE
        if(repBalance + totalRepDifference <= 0):
            totalRepDifference = -1*repBalance
        # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, rest goes to branch as usual later in the process
        if(self.bondPaid[event] < self.bondAmount[branch]*2 && totalRepDifference < 0):
            # done instead of sending to redistrib. pool
            self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the bonded challenger
            self.addRep(branch, self.repIDToIndex(branch, self.forking[event].bondPoster), -totalRepDifference)
            self.bondPaid[event] += -1*totalRepDifference
    
    # Do the second (for each user) based on second report and final outcome
    if(reportValue && !self.branch[branch].penalized[lastPeriod][msg.sender].event[event] && outcome!=0):
        ethics = self.getEthicReport(branch, lastPeriod, event, msg.sender)
        # wrong
        #184467440737095520 == 0.01 in fxp
        if(reportValue > outcome+184467440737095520 or reportValue < outcome-184467440737095520):
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                # makes it so 1.5 penalty isn't super harsh for a scalar / categorical
                if(outcome == 3*ONEHALF && (scalar(event) or categorical(event))):
                    reportValue += ONE
                diff = reportValue - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*p - ONE)/ONE
        # right
        else:
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                # makes it so 1.5 penalty isn't super harsh for a scalar / categorical
                if(outcome == 3*ONEHALF && (scalar(event) or categorical(event))):
                    reportValue += ONE
                diff = reportValue - outcome    
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
        #smoothedRep = oldRep*.8 + newRep*.2
        smoothedRep = oldRep * 14757395258967642112/ONE + newRep * 3689348814741910528/ONE
        repChange = smoothedRep - oldRep
        newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        totalRepDifference = repChange
        # for ethicality if diff. appeal then pay back the fork bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
        if(ethics != ethic_catch(self.getEthical(event)) && totalRepDifference >=0):
            totalRepDifference = -184467440737095520*repBalance / ONE
        if(repBalance + repChange <= 0):
            totalRepDifference = -1*repBalance
        if(self.bondPaid[event] < self.bondAmount[branch]*2 && totalRepDifference < 0):
            # done instead of sending to redistrib. pool
            self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the bonded challenger
            self.addRep(branch, self.repIDToIndex(branch, self.forking[event].bondPoster), -totalRepDifference)
            self.bondPaid[event] += -1*totalRepDifference
        
        self.branch[branch].penalized[lastPeriod][msg.sender].event[event] = 1
        self.branch[branch].penalized[lastPeriod][msg.sender].num += 1
        if(self.getNumReportsActual(branch, lastPeriod, msg.sender)==self.branch[branch].penalized[lastPeriod][msg.sender].num):
            if(newAfterRep <= 0):
                newAfterRep = 0
                self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod
            self.branch[branch].denominator[lastPeriod] += newAfterRep
            totalRepDifference = newAfterRep - oldRep
            if(repBalance + totalRepDifference <= 0):
                totalRepDifference = -1*repBalance
            if(totalRepDifference<0):
                # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
                # sends that rep to the branch
                self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)

def proportionCorrectForkEvent(event):
    refund()
    p = 0
    outcome = catch(self.getForkOutcome(event))
    if(outcome!=0):
        # binary
        if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
            # subtract 1 to get it from 0 to 1
            avgOutcome = self.getForkOutcome(event) - ONE
            # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
            if(outcome == ONE):
                p = ONE - avgOutcome
            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
            if(outcome == 2 * ONE):
                p = avgOutcome
            if(outcome == 3 * ONEHALF):
                return(0)
        return(p)
    else:
        return(0)


macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)
    
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro abs($a):
    if($a<0):
        $a = -$a
    $a
    
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD


inset('refund.se')

event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)
event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 9
# Boolean success/failure
macro SUCCESS: 1
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_SAME_BLOCK_PROHIBITED: 22

macro fee_percent($market_fee, $price, $cumScale):
    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)

macro remove_trade($trade_id, $market):
    self.remove_trade($trade_id)
    self.remove_trade_from_market($market, $trade_id)

#
# Trade
#
# Errors:
    # -1: oracle only branch
    # -2: bad trade hash
    # -3: trader doesn't exist / own shares in this market
    # -4: must buy at least .00000001 in value
    # 10: insufficient balance
#Exchange(Market, outcome, sender, amount, receiver, payment) - transfers amount shares from sender to receiver for payment amount
#max value is max amount to spend to buy [including fees]
#max amount is max shares to sell
# 500k gas
def trade(max_value, max_amount, trade_ids:arr):
    refund()
    if(self.getOracleOnly(branch)):
        return(-1)
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha256(tradeInfo, items=3)
    if(self.checkHash(tradeHash, msg.sender)==-1):
        return(-2)
    max_value = max_value
    max_amount = max_amount
    # Try to fulfill each trade passed
    t = 0
    while t < len(trade_ids):
        trade_id = trade_ids[t]
        # Get trade
        trade = array(TRADE_FIELDS)
        trade = self.get_trade(trade_id, outitems=TRADE_FIELDS)
        if !trade:
            return(0)
        # Get market
        type = trade[1]
        market = trade[2]
        creator = self.getCreator(market)
        amount = trade[3]
        price = trade[4]
        owner = trade[5]
        outcome = trade[7]
        if(owner == msg.sender or owner == tx.origin):
            return(0)
        # Make sure the trade has been mined, obvious HFT prevention
        if block.number <= trade[6]:
            return(TRADE_SAME_BLOCK_PROHIBITED)
        branch = self.getBranchID(market)
        trading_fee = self.getTradingFee(market)
        cumScale = self.getCumScale(market)
        fee = fee_percent(trading_fee, price, cumScale)

        # Fill buy order
        if type == BID:
            # Get available balance of shares
            participantNumber = self.getParticipantNumber(market, msg.sender)
            balance = self.getParticipantSharesPurchased(market, participantNumber, outcome)
            if(balance > 0 and max_amount > 0):
                if(self.getParticipantID(market, participantNumber) != msg.sender):
                    return(-3)
                makerFeeRate = self.getMakerFees(market)
                sender = self.getParticipantNumber(market, msg.sender)
                ownerNum = self.getParticipantNumber(market, owner)
                # Determine fill amount
                fill = min(amount, min(balance, max_amount))
                # Calculate value
                value = (fill * price)/ONE
                # must trade at least 0.00000001 in value
                if(value < 184467440738):
                    return(-4)
                # Update trade amount or remove
                if fill < amount:
                    self.fill_trade(trade_id, fill)
                else:
                    remove_trade(trade_id, market)
                # Update balances
                self.modifyParticipantShares(market, sender, outcome, -fill, 0)
                self.modifyParticipantShares(market, ownerNum, outcome, fill, 0)
                # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
                fee = value * fee / ONE
                # THREEFOURTHS is 3/4
                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
                takerFeesTotal = branchFees + creatorFees
                self.addCash(msg.sender, value-takerFeesTotal)
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                self.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                self.addCash(creator, creatorFees)
                self.subtractCash(market, value)

                # other party [maker] pay their part of the fee here too
                fee = fee * makerFeeRate / ONE
                self.subtractCash(market, fee)
                self.addCash(creator, fee/2)
                self.addCash(branch, fee/2)
                
                # needed to keep track of how many fees a market has raised
                self.addFees(market, fee+takerFeesTotal)
                # Update max_amount
                max_amount -= fill
                # Log transaction
                log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)
            else:
                return(INSUFFICIENT_BALANCE)
        elif type == ASK:
            balance = self.balance(msg.sender)
            makerFeeRate = self.getMakerFees(market)
            feeRate = 3*2**64/2**65 - makerFeeRate
            maxAmountGivenBalance = balance*2**64/(feeRate+2**64)
            max_value = min(maxAmountGivenBalance, max_value)
            if max_value > 0:
                # Calculate value of trade
                trade_value = amount * price / ONE
                # Determine fill value
                value = min(max_value, trade_value)
                if(value < 184467440738):
                    return(-4)
                fee = value * fee / ONE
                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
                takerFeesTotal = branchFees + creatorFees
                if(balance < (value + takerFeesTotal)):
                    return(INSUFFICIENT_BALANCE)
                fill = 0
                # Calculate fill amount, update trade amount or remove filled trade
                if value < trade_value:
                    fill = value*ONE / price
                    self.fill_trade(trade_id, fill)
                else:
                    fill = amount
                    remove_trade(trade_id, market)
                participantNumber = self.getParticipantNumber(market, msg.sender)
                # if participant doesn't exist in market, add them
                if(msg.sender != self.getParticipantID(market, participantNumber)):
                    participantNumber = self.addParticipant(market, msg.sender)
                
                # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]
                self.modifyParticipantShares(market, participantNumber, outcome, fill, 0)
                # Transfer cash from user to person who has ask order and pay fee to branch and market creator
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                self.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                self.addCash(creator, creatorFees)
                cost = value + takerFeesTotal
                self.addCash(owner, value)
                self.subtractCash(msg.sender, cost)

                # other party [maker] pay their part of the fee here too
                fee = fee * makerFeeRate / ONE
                self.subtractCash(market, fee)
                self.addCash(creator, fee/2)
                self.addCash(branch, fee/2)
                
                self.addFees(market, fee+takerFeesTotal)
                # Update max_value
                max_value -= value
                # Log transaction
                log(type=log_fill_tx, market, msg.sender, owner, BID, price, fill, trade_id, outcome)
            else:
                return(INSUFFICIENT_BALANCE)

        # Log price, fill amount, type and timestamp
        log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)
        # Next trade
        t += 1
    return([SUCCESS, max_value, max_amount]: arr)

macro refund():
    if(msg.value > 0):
        send(msg.sender, msg.value)

macro ONE: 2^64

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400
inset('refund.se')

# four winning outcomes
def fourOutcomes(market, winningOutcome: arr, events: arr, sender):
    refund()
    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high
    scalarOne = -1
    scalarTwo = -1
    if(((self.getMaxValue(events[0])!=TWO || self.getMinValue(events[0])!=ONE) && self.getNumOutcomes(events[0])==2) || self.getOutcome(events[0])==3*ONEHALF):
        scalarOne = 0
    if(((self.getMaxValue(events[1])!=TWO || self.getMinValue(events[1])!=ONE) && self.getNumOutcomes(events[1])==2) || self.getOutcome(events[1])==3*ONEHALF):
        if(scalarOne == -1):
            scalarOne = 1
        else:
            scalarTwo = 1
    elif(((self.getMaxValue(events[2])!=TWO || self.getMinValue(events[2])!=ONE) && self.getNumOutcomes(events[2])==2) || self.getOutcome(events[2])==3*ONEHALF):
        scalarTwo = 2
    outcomeOne = self.getOutcome(events[scalarOne])
    minValueOne = self.getMinValue(events[scalarOne])
    maxValueOne = self.getMaxValue(events[scalarOne])
    if(outcomeOne>maxValueOne):
        outcomeOne = maxValueOne
    elif(outcomeOne<minValueOne):
        outcomeOne = minValueOne
    outcomeTwo = self.getOutcome(events[scalarTwo])
    minValueTwo = self.getMinValue(events[scalarTwo])
    maxValueTwo = self.getMaxValue(events[scalarTwo])
    if(outcomeTwo>maxValueTwo):
        outcomeTwo = maxValueTwo
    elif(outcomeTwo<minValueTwo):
        outcomeTwo = minValueTwo

    outcomeOneHighSidePercent = ONE*(outcomeOne - minValueOne) / (maxValueOne - minValueOne)
    outcomeOneLowSidePercent = ONE - outcomeOneHighSidePercent
    outcomeTwoHighSidePercent = ONE*(outcomeTwo - minValueTwo) / (maxValueTwo - minValueTwo)
    outcomeTwoLowSidePercent = ONE - outcomeTwoHighSidePercent

    # price is in fixed point
    # share four goes with the high-high side
    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / ONE
    # share three goes with the low-high side
    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / ONE
    # share two goes with the high-low side
    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / ONE
    # share one goes with the low-low
    # both fixed point so div by ONE to keep in fixed point
    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / ONE
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, sender)
    participant = self.getParticipantID(market, participantNumber)
    n = 0
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)
        # low-low
        if(n==0):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/ONE*pricePerShare1/ONE)
            self.addCash(participant, sharesOwned*self.getCumScale(market)/ONE*pricePerShare1/ONE)
        # high-low
        elif(n==1):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/ONE*pricePerShare2/ONE)
            self.addCash(participant, sharesOwned*self.getCumScale(market)/ONE*pricePerShare2/ONE)
        # low-high
        elif(n==2):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/ONE*pricePerShare3/ONE)
            self.addCash(participant, sharesOwned*self.getCumScale(market)/ONE*pricePerShare3/ONE)
        # high-high
        elif(n==3):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/ONE*pricePerShare4/ONE)
            self.addCash(participant, sharesOwned*self.getCumScale(market)/ONE*pricePerShare4/ONE)
        n+=1
    return(1)
def createSingleEventMarket(branch, description:str, expirationBlock, minValue, maxValue, numOutcomes, alpha, initialLiquidity, tradingFee, forkSelection):
    return(self.createMarket(branch, description, alpha, initialLiquidity, tradingFee, [self.createEvent(branch, description, expirationBlock, minValue, maxValue, numOutcomes)], forkSelection))

inset('refund.se')

# eight winning outcomes
def eightOutcomes(market, winningOutcome: arr, events: arr, sender):
    refund()
    outcomeOne = self.getOutcome(events[0])
    minValueOne = self.getMinValue(events[0])
    maxValueOne = self.getMaxValue(events[0])
    if(outcomeOne>maxValueOne):
        outcomeOne = maxValueOne
    elif(outcomeOne<minValueOne):
        outcomeOne = minValueOne
    outcomeTwo = self.getOutcome(events[1])
    minValueTwo = self.getMinValue(events[1])
    maxValueTwo = self.getMaxValue(events[1])
    if(outcomeTwo>maxValueTwo):
        outcomeTwo = maxValueTwo
    elif(outcomeTwo<minValueTwo):
        outcomeTwo = minValueTwo
    outcomeThree = self.getOutcome(events[2])
    minValueThree = self.getMinValue(events[2])
    maxValueThree = self.getMaxValue(events[2])
    if(outcomeThree>maxValueThree):
        outcomeThree = maxValueThree
    elif(outcomeThree<minValueThree):
        outcomeThree = minValueThree

    outcomeOneHighSidePercent = ONE*(outcomeOne - minValueOne) / (maxValueOne - minValueOne)
    outcomeOneLowSidePercent = ONE - outcomeOneHighSidePercent
    outcomeTwoHighSidePercent = ONE*(outcomeTwo - minValueTwo) / (maxValueTwo - minValueTwo)
    outcomeTwoLowSidePercent = ONE - outcomeTwoHighSidePercent
    outcomeThreeHighSidePercent = ONE*(outcomeThree - minValueThree) / (maxValueThree - minValueThree)
    outcomeThreeLowSidePercent = ONE - outcomeThreeHighSidePercent
            
    # price is in fixed point
    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high
    pricePerShare = array(7)
    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)
    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)
    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (ONE * ONE)
    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)
    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)
    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)
    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)
    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)

    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, sender)
    participant = self.getParticipantID(market, participantNumber)
    
    # for each winning outcome do...
    n = 0
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)
        self.subtractCash(market, sharesOwned*pricePerShare[n]*self.getCumScale(market)/ONE)
        self.addCash(participant, sharesOwned*self.getCumScale(market)/ONE*pricePerShare[n]/ONE)
        n+=1
    return(1)
inset('refund.se')

# mutex result non scalar not .5
# one winning outcome
def oneOutcome(market, winningOutcome, sender):
    refund()
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, sender)
    sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome)
    participant = self.getParticipantID(market, participantNumber)
    self.modifyParticipantShares(market, participantNumber, winningOutcome, -sharesOwned)
    self.subtractCash(market, sharesOwned*self.getCumScale(market)/ONE)
    self.addCash(participant, sharesOwned*self.getCumScale(market)/ONE)
    return(1)
inset('refund.se')

data feeFirst[][]
data periodBalance[][]

# -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]
    # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission
def collectFees(branch):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2):
        return(-2)
    if(!self.getRRDone(branch, msg.sender)):
        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary
        return(-1)
    lastPeriod = self.getVotePeriod(branch) - 1
    if(!self.getFeesCollected(branch, msg.sender, lastPeriod) && self.getReportedPeriod(branch, lastPeriod, msg.sender)):
        newRep = self.getAfterRep(branch, lastPeriod, msg.sender)
        denominator = self.getDenominator(branch, lastPeriod)
        if(!self.feeFirst[branch][lastPeriod]):
            self.feeFirst[branch][lastPeriod] = 1
            self.periodBalance[branch][lastPeriod] = self.getRepBalance(branch, branch)
        gainedRep = newRep * ONE / denominator * self.periodBalance[branch][lastPeriod] / ONE
        #if(lostRep) newRep should be == self.getAfterRep(branch, period, msg.sender) + gainedRep
        #if(gainedRep) newRep should be == self.getBeforeRep(branch, period, msg.sender) + gainedRep
        self.addRep(branch, self.repIDToIndex(branch, msg.sender), gainedRep)
        self.subtractRep(branch, self.repIDToIndex(branch, branch), gainedRep)
        cash = self.getInitialBalance(branch, lastPeriod) * newRep / denominator
        self.addCash(msg.sender, cash)
        self.subtractCash(branch, cash)
        self.setFeesCollected(branch, msg.sender, lastPeriod)
        return(1)
    else:
        return(0)

inset('refund.se')

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)


def getDescription(ID):
	refund()
	length=self.Info[ID].descriptionLength
	return(load(self.Info[ID].description[0], chars=length): str)

def getDescriptionLength(ID):
	refund()
	return(self.Info[ID].descriptionLength)

def getCreator(ID):
	refund()
	return(self.Info[ID].creator)

def getCreationFee(ID):
	refund()
	return(self.Info[ID].creationFee)

# @return 1 if success, 0 if creator already exists
def setInfo(ID, description: str, creator, fee):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	# check that msg.sender is one of our function contracts
	if(self.Info[ID].creator == 0):
		save(self.Info[ID].description[0], description, chars=len(description))
		self.Info[ID].descriptionLength = len(description)
		self.Info[ID].creationFee = fee
		self.Info[ID].creator = creator
		return(1)
	else:
		return(0)

inset('refund.se')

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID), activeRep, fork)

data whitelists[](addresses[], taken)


def checkWhitelist(address):
    refund()
    return(self.whitelists[msg.sender].addresses[address])

def getActiveRep(branch):
    return(self.Reporting[branch].activeRep)
    
def adjustActiveRep(branch, amount):
    self.Reporting[branch].activeRep += amount
    return(1)

def setFork(branch):
    self.Reporting[branch].fork = 1
    return(1)
    
def getFork(branch):
    return(self.Reporting[branch].fork)

def checkContractWhitelist(contract, address):
    refund()
    return(self.whitelists[contract].addresses[address])

def setWhitelist(contract, addresses:arr):
    refund()
    if self.whitelists[contract].taken:
        return(text("ERROR: you have to vote to change a whitelist"):str)
    else:
        self.whitelists[contract].taken = 1
        i = 0
        l = len(addresses)
        while i <l:
            address = addresses[i]
            self.whitelists[contract].addresses[addresses] = 1
            i += 1
        return(text("SUCCESS"):str)

# @return reputation value
def getRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].reputation[repIndex].repValue)

# @return reputation value
def getRepBalance(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

def getDormantRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].dormantRep[repIndex].repValue)

# @return reputation value
# getDormantRepBalance
def balanceOf(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].dormantRep[repIndex].repValue)
    
# return total supply of dormant rep
def totalSupply(branch):
    return((self.Reporting[branch].totalRep - self.Reporting[branch].activeRep))

def getReporterID(branch, index):
    refund()
    return(self.Reporting[branch].reputation[index].reporterID)

def getTotalRep(branch):
    refund()
    return(self.Reporting[branch].totalRep)

# will return 0s for array values after it's looped through all the ones you
# have an actual balance in
def getReputation(address):
    refund()
    branchListCount = self.getNumBranches()
    if(address):
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = msg.sender
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)

def getNumberReporters(branch):
    refund()
    return(self.Reporting[branch].numberReporters)

def repIDToIndex(branch, repID):
    refund()
    return(self.Reporting[branch].repIDtoIndex[repID])

def hashReport(report: arr, salt):
    refund()
    hashInfo = array(len(report) + 2)
    hashInfo[0] = msg.sender
    hashInfo[1] = salt
    i = 2
    while i < (len(report) + 2):
        hashInfo[i] = report[i-2]
        i += 1
    reportHash = sha256(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# check that msg.sender is one of our function contracts
def setInitialReporters(parent, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add branch as a "reporter"
    self.Reporting[branchID].numberReporters = 1
    self.Reporting[branchID].repIDtoIndex[branchID] = 0
    self.Reporting[branchID].reputation[0].repValue = 0
    self.Reporting[branchID].reputation[0].reporterID = branchID
    return(1)

def addReporter(branch, sender, amount, dormant, repToBonderOrBranch):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    refund()
    reporterIndex = self.Reporting[branch].numberReporters
    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex
    self.Reporting[branch].reputation[reporterIndex].repValue = amount
    self.Reporting[branch].reputation[reporterIndex].reporterID = sender
    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender
    self.Reporting[branchID].dormantRep[i].repValue = dormant
    self.Reporting[branch].activeRep += amount + repToBonderOrBranch
    self.Reporting[branchID].totalRep += amount + dormant + repToBonderOrBranch
    self.Reporting[branch].numberReporters += 1
    return(1)

def addRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue += value
    return(1)

def subtractRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue -= value
    return(1)

def setRep(branch, index, newRep):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    oldRep = self.Reporting[branch].reputation[index].repValue
    self.Reporting[branch].reputation[index].repValue = newRep
    self.Reporting[branch].activeRep += newRep - oldRep
    self.Reporting[branch].totalRep += newRep - oldRep
    return(1)

def addDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue += value
    return(1)

def subtractDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue -= value
    return(1)

# check that msg.sender is one of our function contracts
# make this cheaper
def setSaleDistribution(addresses: arr, balances: arr, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    i = 0
    while i < len(addresses):
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]
        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters
        self.Reporting[branchID].numberReporters += 1
        i+=1
    return(1)

inset('refund.se')

macro fx_floor_log2($x):
    with $y = $x / 0x10000000000000000:
        with $lo = 0:
            with $hi = 191:
                with $mid = ($hi + $lo)/2:
                    while (($lo + 1) != $hi):
                        if $y < 2**$mid:
                            $hi = $mid
                        else:
                            $lo = $mid
                        $mid = ($hi + $lo)/2
                    $lo

macro fx_log2_small($x):
    with $result = -0x48A49EAD9B2CD16BE:
        with $temp = $x:
            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000

macro fx_log2($x):
    with $y = fx_floor_log2($x):
        with $z = $x / 2**$y:
            $y * 0x10000000000000000 + fx_log2_small($z)

macro fx_log($x):
    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177

macro fx_exp2_small($x):
    with $result = 0x10000000000000000:
        with $temp = $x:
            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xE35846B82505F32*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA184897C5558D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x162C023B2A1D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1B5250C02BF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E87B8E21*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1C768AA3*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x164F0A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result + 0x1B08D3*$temp / 0x10000000000000000

macro fx_exp2($x):
    with $y = $x / 0x10000000000000000:
        with $z = $x % 0x10000000000000000:
            fx_exp2_small($z) * 2**$y

macro fx_exp($x):
    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)

def fx_exp(x):
    refund()
    return(fx_exp(x))

def fx_log(x):
    refund()
    return(fx_log(x))

def sqrt(n):
    refund()
    val = n
    i = 0
    while i < 11:
        val = (val + n*ONE/val)/2
        i += 1
    return val
inset('refund.se')

data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, originalEthicality, final, bondPoster, bondReturned)

def getBondReturned(event):
    return(self.roundTwo[event].bondReturned)
    
def setBondReturned(event):
    self.roundTwo[event].bondReturned = 1
    return(1)

def getRoundTwo(event):
    refund()
    return(self.roundTwo[event].roundTwo)
    
def setRoundTwo(event, roundTwo):
    self.roundTwo[event].roundTwo = roundTwo
    return(1)
    
def getBondPoster(event):
    refund()
    return(self.roundTwo[event].bondPoster)
    
def setBondPoster(event, bondPoster):
    self.roundTwo[event].bondPoster = bondPoster
    return(1)

def getFinal(event):
    refund()
    return(self.roundTwo[event].final)

def setFinal(event):
    self.roundTwo[event].final = 1
    return(1)
    
def getOriginalOutcome(event):
    refund()
    return(self.roundTwo[event].originalOutcome)

def setOriginalOutcome(event, originalOutcome):
    self.roundTwo[event].originalOutcome = originalOutcome
    return(1)

def getOriginalEthicality(event):
    refund()
    return(self.roundTwo[event].originalEthicality)
    
def setOriginalEthicality(event, ethicality):
    self.roundTwo[event].originalEthicality = ethicality
    return(1)

def getOriginalVotePeriod(event):
    refund()
    return(self.roundTwo[event].originalVotePeriod)

def setOriginalVotePeriod(event, period):
    self.roundTwo[event].originalVotePeriod = period
    return(1)

inset('refund.se')

# [branchID][votingPeriod]
# reporthash is [reporterID] = hash
data EventsExpDates[][](numberEvents, numberRemoved, events[], numEventsToReportOn, reportHash[][], shareValue, roundTwoNumEvents, subsidy[])

data EventIDToIndex[][]

data branches[](beforeRep[][], afterRep[][], periodDormantRep[][], ethics[][](event[]), report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], numReportsActual[][], reportedPeriod[][], repEvent[][], lesserReportNum[][], periodRepConstant[][])

data requiredEvents[]

# branch, period as params
data numReqEvents[][]

data mode_items[][](report_value[], current_mode, current_mode_items)


def refundCost(to, value):
    send(to, value)
    return(1)

def getSubsidy(branch, period, event):
    return(self.EventsExpDates[branch][period].subsidy[event])

def getPeriodRepConstant(branch, votePeriod, sender):
    return(self.branches[branch].periodRepConstant[votePeriod][sender])

def setPeriodRepConstant(branch, votePeriod, sender, value):
    self.branches[branch].periodRepConstant[votePeriod][sender] = value
    return(1)

def getLesserReportNum(branch, period, event):
    return(self.branches[branch].lesserReportNum[period][event])

def getCurrentModeItems(period, event):
    return(self.mode_items[period][event].current_mode_items)

def getCurrentMode(period, event):
    return(self.mode_items[period][event].current_mode)
    
# returns weight of a report value for the mode
def getWeightOfReport(period, event, report):
    return(self.mode_items[period][event].report_value[report])

def getRepEvent(branch, votePeriod, event):
    return(self.branches[branch].repEvent[votePeriod][event])

def getReportedPeriod(branch, period, reporter):
    return(self.branches[branch].reportedPeriod[period][reporter])

def getEthicReport(branch, period, event, sender):
    return(self.branches[branch].ethics[period][sender].event[event])

def getNumReportsExpectedEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])

def getNumReportsEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsEvent[votePeriod][eventID])

def getReport(branch, period, event, sender):
    #if(whitelist):
    return(self.branches[branch].report[period][sender].event[event])

def getBeforeRep(branch, period, sender):
    return(self.branches[branch].beforeRep[period][sender])

def getAfterRep(branch, period, sender):
    return(self.branches[branch].afterRep[period][sender])
    
def getPeriodDormantRep(branch, period, sender):
    return(self.branches[branch].periodDormantRep[period][sender])

def getNumReportsActual(branch, votePeriod, sender):
    return(self.branches[branch].numReportsActual[sender][votePeriod])

def getNumRoundTwo(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].roundTwoNumEvents)

def addRoundTwo(branch, period):
    refund()
    self.EventsExpDates[branch][period].roundTwoNumEvents += 1
    return(1)

def getRequired(event):
    return(self.requiredEvents[event])
    
def getNumRequired(branch, period):
    return(self.numReqEvents[branch][period])
    
# Return 0 means already required
def setEventRequired(branch, period, event):
    if(self.requiredEvents[event]==0):
        self.requiredEvents[event] = 1
        self.numReqEvents[branch][period] += 1
        return(1)
    else:
        return(0)

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)
    
def getEventsToReportOn(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents*2)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        reportingThreshold = self.calculateReportingThreshold(branch, events[i], expDateIndex, msg.sender)
        x = array(1)
        x[0] = msg.sender + events[i]
        shaHash = sha3(x, items=1)/ONE
        if((shaHash < reportingThreshold || shaHash<self.getReportingThreshold(events[i]) || self.getRequired(events[i])) && !self.getOutcome(events[i])):
            events[i+1] = 1
        else:
            events[i+1] = 0
        i += 2
    return(events: arr)
    

# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
def calculateReportingThreshold(branch, eventID, votePeriod, sender):
    repConstant = self.getPeriodRepConstant(branch, votePeriod, sender)
    if(repConstant==0):
        logOutput = self.fx_log(self.getRepBalance(branch, sender)*ONE/self.getActiveRep(branch))
        repConstant = self.fx_exp(22136092888451461120*logOutput/ONE) + 18446744073709552
        expectedEventsForReporter = repConstant * self.getNumEventsToReportOn(branch, votePeriod)
        total = expectedEventsForReporter
        eventsInPeriod = self.getNumberEvents(branch, expDateIndex)-self.getNumRemoved(branch, votePeriod)
        numRequiredEvents = self.getNumRequired(branch, votePeriod)
        minimum = min(30-numRequiredEvents, eventsInPeriod-numRequiredEvents)
        if(total/ONE < minimum):
            total = minimum*ONE
            repConstant = repConstant*ratio / ONE
        self.setPeriodRepConstant(branch, votePeriod, sender, repConstant)
    reportingThreshold = self.getLesserReportNum(branch, votePeriod, eventID)*repConstant*ONE
    return(reportingThreshold)
    
def getEventsRange(branch, expDateIndex, start, end):
    refund()
    numEvents = end-start
    events = array(numEvents)
    i = start
    index = 0
    while i < end:
        events[index] = self.EventsExpDates[branch][expDateIndex].events[i]
        index += 1
        i += 1
    return(events: arr)
    
def getEventIndex(period, eventID):
    refund()
    return(self.EventIDToIndex[period][eventID])

# we should probably make this bonded too
# -1: voting not started
def setNumEventsToReportOn(branch):
    refund()
    # after voting has started
    expDateIndex = self.getVotePeriod(branch)
    self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = (self.EventsExpDates[branch][expDateIndex].numberEvents - self.numReqEvents[branch][expDateIndex] - self.EventsExpDates[branch][expDateIndex].numberRemoved)*self.getBaseReporters(branch)
    return(1)

def getNumEventsToReportOn(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)

def getShareValue(branch, expIndex):
    refund()
    return(self.EventsExpDates[branch][expIndex].shareValue)

def getNumberEvents(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, eventIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getReportHash(branch, expDateIndex, reporter, event):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID, subsidy):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
    self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents
    self.EventsExpDates[branch][futurePeriod].numberEvents += 1
    self.EventsExpDates[branch][futurePeriod].subsidy[eventID] += subsidy
    return(1)

def removeEvent(branch, period):
    refund()
    self.EventsExpDates[branch][period].numberRemoved += 1
    return(1)

def getNumRemoved(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].numberRemoved)

def adjustPeriodShareValueOutstanding(branch, expIndex, amount):
    refund()
    self.EventsExpDates[branch][expIndex].shareValue += amount
    return(1)

def setReportHash(branch, expDateIndex, reporter, reportHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash
    return(1)

# called in case an event doesn't get reported on at all in a period
def moveEvent(branch, event):
    if(self.getVotePeriod(branch) > self.getExpiration(event)/self.getPeriodLength(branch) && !self.getUncaughtOutcome(event)):
        # add to next expiration period
        self.addEvent(branch, block.timestamp/self.getPeriodLength(branch), event)
        self.setExpiration(event, block.timestamp)
        return(1)
    else:
        return(0)
        
def addToWeightOfReport(period, event, report, amount):
    self.mode_items[period][event].report_value[report] += amount
    return(1)
    
def setCurrentMode(period, event, mode):
    self.mode_items[period][event].current_mode = mode
    return(1)
    
# basically setting current mode's weight
def setCurrentModeItems(period, event, modeReport):
    self.mode_items[period][event].current_mode = self.mode_items[period][event].report_value[modeReport]
    return(1)

def addRepEvent(branch, votePeriod, event, amount):
    self.branches[branch].repEvent[votePeriod][event] += amount
    return(1)
    
def setReportedPeriod(branch, period, reporter):
    self.branches[branch].reportedPeriod[period][reporter] = 1
    return(1)

def setEthicReport(branch, period, event, ethics, sender):
    self.branches[branch].ethics[period][sender].event[event] = ethics
    return(1)

def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num
    return(1)

def setNumReportsEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsEvent[votePeriod][eventID] = num
    return(1)
    
def addReportToEvent(branch, votePeriod, eventID, sender):
    self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
    self.branches[branch].numReportsActual[sender][votePeriod] += 1
    return(1)

def addReportExpected(branch, votePeriod, eventID):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1
    return(1)

def setReport(branch, period, event, report, sender):
    self.branches[branch].report[period][sender].event[event] = report
    return(1)

def setBeforeRep(branch, period, rep, sender):
    self.branches[branch].beforeRep[period][sender] = rep
    return(rep)

def setAfterRep(branch, period, rep, sender):
    self.branches[branch].afterRep[period][sender] = rep
    return(rep)

def setPeriodDormantRep(branch, period, rep, sender):
    self.branches[branch].periodDormantRep[period][sender] = rep
    return(rep)
    
def setLesserReportNum(branch, period, event, num):
    self.branches[branch].lesserReportNum[period][event] = num
    return(1)
    
#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.
def setReportingThreshold(event):
    refund()
    # first check is if event expDate is in the current vote period and second is if blockNum is near expiration of commit period (within 24 hr.)
    # final check is if < 3 reports so far
    # so if in 24 hr we'd be in the next half of the vote period, we're within 24 hr of the end of this one
    branch = self.getBranch(event)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    votePeriod = self.getVotePeriod(branch)
    if(votePeriod==self.getExpiration(event)/periodLength and (((block.timestamp + TWENTYFOURHR) % periodLength) > periodLength/2) and self.branches[branch].numReportsExpectedEvent[votePeriod][event]<3):
        self.setThreshold(event, 2**192)
        return(1)
    else:
        return(0)
inset('refund.se')

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period (should always be 1 behind block.timestamp/periodlength or current EventsExpDates index)
# period parameter for reporting
# currentExpPeriod = (block.timestamp / self.Branches[branch].periodLength)
# currentExpPeriod - 1 is what's up for reporting at any given time
# should add a min initial liquidity property, for non pm branches it'd be low and .5*minInitialLiquidity is == fee for event
# could also add an event fee parameter
# How to set minimum reporting fee guidelines for reporters, abs. minimum should be calc. as follows:
    #Volume per period * .5 * fee * ev/ebit * 6 >= rep market cap
    #Say ev/ebit or valuation is 15, so:
    #45 * fee * volume per period = rep market cap

    #Want:
        #Rep market cap >> outstanding shares value at all times
data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod, baseReporters, forkPeriod, eventForkedOver, parent)

# first param is the branch, second param is the subcurrency contract
data cash[][]

data branchList[]

data branchListCount


# call once after uploading (externed method not allowed in init)
def initDefaultBranch():
    refund()
    return(self.initiateOwner(1010101))

def getEventForkedOver(branch):
    return(self.Branches[branch].eventForkedOver)

def setEventForkedOver(branch, event):
    self.Branches[branch].eventForkedOver = event
    return(1)

def getBaseReporters(branch):
    refund()
    return(self.Branches[branch].baseReporters)
    
def setBaseReporters(branch, num):
    refund()
    self.Branches[branch].baseReporters = num
    return(1)

def getOracleOnly(branch):
    refund()
    return(self.Branches[branch].oracleOnly)

def getVotePeriod(branch):
    refund()
    return(self.Branches[branch].currentVotePeriod)

def getPeriodLength(branch):
    refund()
    return(self.Branches[branch].periodLength)

# branch cash balance at start of period
def setInitialBalance(branch, period, balance):
    refund()
    self.Branches[branch].balance[period] = balance
    return(balance)

def getInitialBalance(branch, period):
    refund()
    return(self.Branches[branch].balance[period])

# @return all markets in a branch
def getMarketsInBranch(branch):
    refund()
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)
   
   
def getParent(branch):
    return(self.Branches[branch].parent)

# @return all markets in a branch
def getSomeMarketsInBranch(branch, initial, last):
    refund()
    numMarkets = last - initial
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[initial+i]
        i += 1
    return(markets: arr)

def getNumMarketsBranch(branch):
    refund()
    return(self.Branches[branch].numMarkets)

def getMinTradingFee(branch):
    refund()
    return(self.Branches[branch].minTradingFee)

# @return all branches
def getBranches():
    refund()
    b = 0
    numBranches = self.branchListCount
    branches = array(numBranches)
    while b < numBranches:
        branches[b] = self.branchList[b]
        b += 1
    return(branches: arr)

def getNumBranches():
    refund()
    return(self.branchListCount)

def getBranchByNum(branchNumber):
    refund()
    return(self.branchList[branchNumber])

def getCreationDate(ID):
    refund()
    return(self.Branches[ID].creationDate)

# check that msg.sender is one of our function contracts
def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    if(self.Branches[ID].periodLength==0):
        self.Branches[ID].currentVotePeriod = currentVotePeriod
        self.Branches[ID].periodLength = periodLength
        self.Branches[ID].minTradingFee = minTradingFee
        self.branchList[self.branchListCount] = ID
        self.branchListCount += 1
        self.Branches[ID].creationDate = block.timestamp
        self.Branches[ID].parentPeriod = parentPeriod
        self.Branches[ID].oracleOnly = oracleOnly
        self.Branches[ID].parent = parent
        self.initiateOwner(ID)
        return(1)
    else:
        return(0)

def getParentPeriod(branch):
    refund()
    return(self.Branches[branch].parentPeriod)

def incrementPeriod(branch):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    self.Branches[branch].currentVotePeriod += 1
    return(1)

# check that msg.sender is one of our function contracts
def addMarketToBranch(branch, market):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    numMarkets = self.Branches[branch].numMarkets
    self.Branches[branch].markets[numMarkets] = market
    self.Branches[branch].numMarkets += 1
    return(1)
    
def setForkPeriod(branch):
    self.Branches[branch].forkPeriod = self.Branches[branch].currentVotePeriod
    return(1)
    
def getForkPeriod(branch):
    return(self.Branches[branch].forkPeriod)
macro refund():
    if(msg.value > 0):
        send(msg.sender, msg.value)

macro ONE: 2^64

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400
inset('refund.se')

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
    # [1, event, event, 2, event, 3, event, event, event]
    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
# tradingPeriod is which eventexpperiod market expires in
data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, pushingForward, bondsMan, originalPeriod, trade_ids[](id, next_id, prev_id), last_trade, total_trades, tag1, tag2, tag3, makerFees, extraInfo[], extraInfoLen, sharesValue, gasSubsidy, fees, blockNum)

def addFees(market, amount):
    self.Markets[market].fees += amount
    return(1)

def refundClosing(amount, to):
    send(amount, to)
    return(1)

def getFees(market):
    return(self.Markets[market].fees)

def getMakerFees(market):
    return(self.Markets[market].makerFees)

def getgasSubsidy(market):
    return(self.Markets[market].gasSubsidy)

def getSharesValue(market):
    return(self.Markets[market].sharesValue)

def returnTags(market):
    tags = array(3)
    tags[0] = self.Markets[market].tag1
    tags[1] = self.Markets[market].tag2
    tags[2] = self.Markets[market].tag3
    return(tags: arr)

def getTotalSharesPurchased(market):
    refund()
    total = 0
    n = self.Markets[market].numOutcomes
    i = 1
    while i <= n:
      total += self.Markets[market].sharesPurchased[i]
      i += 1
    return(total)

def getMarketEvent(market, index):
    refund()
    return(self.Markets[market].events[index])

def getCreationBlock(market):
    return(self.Markets[market].blockNum)

def getMarketEvents(market):
    refund()
    return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)

def getSharesPurchased(market, outcome):
    refund()
    return(self.Markets[market].sharesPurchased[outcome])

def getExtraInfo(market):
    refund()
    length=self.Markets[market].extraInfoLen
    return(load(self.Markets[market].extraInfo[0], chars=length): str)

def getVolume(market):
    refund()
    return(self.Markets[market].volume)

def getParticipantNumber(market, address):
    refund()
    participantNumber = self.Markets[market].addr2participant[address]
    return(participantNumber)

def getParticipantID(market, participantNumber):
    refund()
    return(self.Markets[market].participants[participantNumber].participantID)

def getParticipantSharesPurchased(market, participantNumber, outcome):
    refund()
    return(self.Markets[market].participants[participantNumber].shares[outcome])

def getNumEvents(market):
    refund()
    return(self.Markets[market].lenEvents)

def getCurrentParticipantNumber(market):
    refund()
    return(self.Markets[market].currentParticipant)

def getCumScale(market):
    refund()
    return(self.Markets[market].cumulativeScale)

def getMarketNumOutcomes(market):
    refund()
    return(self.Markets[market].numOutcomes)

def getTradingPeriod(market):
    refund()
    return(self.Markets[market].tradingPeriod)

def getOriginalTradingPeriod(market):
    refund()
    return(self.Markets[market].originalPeriod)

def setTradingPeriod(market, period):
    refund()
    self.Markets[market].tradingPeriod = period
    return(1)

def getTradingFee(market):
    refund()
    return(self.Markets[market].tradingFee)

def getBranchID(market):
    refund()
    return(self.Markets[market].branch)

macro market($marketID):
    self.Markets[$marketID]

macro cumScale($marketID):
    market($marketID).cumulativeScale

macro numOutcomes($marketID):
    market($marketID).numOutcomes

macro sharesPurchased($marketID):
    market($marketID).sharesPurchased

# check that msg.sender is one of our function contracts
def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumScale, numOutcomes, extraInfo: str, gasSubsidy, creationFee, block):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add event list to the market
    save(self.Markets[marketID].events[0], events, items=len(events))
    self.Markets[marketID].lenEvents = len(events)
    save(self.Markets[marketID].extraInfo[0], extraInfo, chars=len(extraInfo))
    self.Markets[marketID].extraInfoLen = len(extraInfo)
    self.Markets[marketID].tradingPeriod = tradingPeriod
    self.Markets[marketID].originalPeriod = tradingPeriod
    self.Markets[marketID].tradingFee = tradingFee
    self.Markets[marketID].branch = branch
    self.Markets[marketID].cumulativeScale = cumScale
    self.Markets[marketID].numOutcomes = numOutcomes
    self.Markets[marketID].tag1 = tag1
    self.Markets[marketID].tag2 = tag2
    self.Markets[marketID].gasSubsidy = gasSubsidy
    self.Markets[marketID].tag3 = tag3
    self.Markets[marketID].makerFees = makerFees
    self.Markets[marketID].fees = creationFee
    self.Markets[marketID].blockNum = block
    return(1)

def addParticipant(market, address):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    participantNumber = self.Markets[market].currentParticipant
    self.Markets[market].participants[participantNumber].participantID = address
    self.Markets[market].addr2participant[address] = participantNumber
    self.Markets[market].currentParticipant += 1
    return(participantNumber)

def modifyShares(marketID, outcome, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    sharesPurchased(marketID)[outcome] += amount
    return(1)
    
def modifySharesValue(marketID, amount):
    self.Markets[marketID].sharesValue += amount
    return(1)

def modifyParticipantShares(marketID, participantNumber, outcome, amount, cancel):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Markets[marketID].participants[participantNumber].shares[outcome] += amount
    if(amount<0):
        amount = amount*-1
    if(cancel):
        amount = -1*amount
    self.Markets[marketID].volume += amount
    return(1)

def setWinningOutcomes(market, outcomes: arr):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))
    return(1)

def getWinningOutcomes(market):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    return(load(self.Markets[market].winningOutcomes[0], items=8): arr)
    
def getOneWinningOutcome(market, num):
    refund()
    # whitelist
    return(self.Markets[market].winningOutcomes[num])

def setTradingFee(market, fee):
    refund()
    self.Markets[market].tradingFee = fee
    return(fee)

def setPushedForward(market, bool, sender):
    refund()
    self.Markets[market].pushingForward = bool
    self.Markets[market].bondsMan = sender
    return(1)

def getPushedForward(market):
    refund()
    return(self.Markets[market].pushingForward)

def getBondsMan(market):
    refund()
    return(self.Markets[market].bondsMan)

def getLastTrade(market):
    refund()
    return(self.Markets[market].last_trade)
    
def addTrade(market, trade_id, last_id):
    refund()
    self.Markets[market].trade_ids[last_id].next_id = trade_id
    self.Markets[market].trade_ids[trade_id].prev_id = last_id
    self.Markets[market].trade_ids[trade_id].id = trade_id
    self.Markets[market].last_trade = trade_id
    self.Markets[market].total_trades += 1
    return(1)
    
def remove_trade_from_market(market_id, trade_id):
    refund()
    prev_id = self.Markets[market_id].trade_ids[trade_id].prev_id
    next_id = self.Markets[market_id].trade_ids[trade_id].next_id
    if prev_id and next_id:
        self.Markets[market_id].trade_ids[prev_id].next_id = next_id
        self.Markets[market_id].trade_ids[next_id].prev_id = prev_id
    elif prev_id:
        self.Markets[market_id].last_trade = prev_id
        self.Markets[market_id].trade_ids[prev_id].next_id = 0

    if next_id:
        self.Markets[market_id].trade_ids[trade_id].next_id = 0
    if prev_id:
        self.Markets[market_id].trade_ids[trade_id].prev_id = 0
    self.Markets[market_id].trade_ids[trade_id].id = 0
    self.Markets[market_id].total_trades -= 1
    return(1)

def get_trade_ids(market_id):
    refund()
    trades_count = self.Markets[market_id].total_trades
    trade_id = self.Markets[market_id].last_trade
    trade_ids = array(trades_count)

    i = 0
    while i < trades_count:
        trade_ids[i] = self.Markets[market_id].trade_ids[trade_id].id
        trade_id = self.Markets[market_id].trade_ids[trade_id].prev_id
        i = i + 1

    if trade_ids:
        return(trade_ids:arr)
    return([FAILURE]:arr)
    
def get_total_trades(market_id):
    refund()
    return(self.Markets[market_id].total_trades)



macro EVENTS_FIELDS: 6
macro OUTCOMES_FIELDS: 2
macro WINNING_OUTCOMES_FIELDS: 8
macro FIELDS: 16

def getMarketInfo(marketID):
    refund()
    index = FIELDS
    participantNumber = self.Markets[marketID].addr2participant[msg.sender]
    descriptionLength = self.getDescriptionLength(marketID)
    traderFields = 1 + self.Markets[marketID].numOutcomes
    with info = array(FIELDS + self.Markets[marketID].currentParticipant*traderFields + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1):
        numEvents = self.Markets[marketID].lenEvents
        info[0] = marketID
        info[1] = self.Markets[marketID].currentParticipant
        info[2] = self.Markets[marketID].makerFees
        info[3] = participantNumber
        info[4] = self.Markets[marketID].numOutcomes
        info[5] = self.Markets[marketID].tradingPeriod
        info[6] = self.Markets[marketID].tradingFee
        info[7] = self.Markets[marketID].branch
        info[8] = self.Markets[marketID].lenEvents
        info[9] = self.Markets[marketID].cumulativeScale
        info[10] = self.Markets[marketID].blockNum
        info[11] = self.getCreationFee(marketID)
        info[12] = self.getCreator(marketID)
        info[13] = self.Markets[marketID].tag1
        info[14] = self.Markets[marketID].tag2
        info[15] = self.Markets[marketID].tag3

        # gather trader(s) info: [trader ID, 1 shares, 2 shares, 3 shares, ...]
        t = 0
        while t < self.Markets[marketID].currentParticipant:
            info[index + t*traderFields] = self.Markets[marketID].participants[t].participantID
            o = 1
            while o < self.Markets[marketID].numOutcomes + 1:
                info[index + t*traderFields + o] = self.Markets[marketID].participants[t].shares[o]
                o += 1
            t += 1
        index += self.Markets[marketID].currentParticipant*traderFields

        # gather event(s) info:
        # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]
        with events = slice(load(self.Markets[marketID].events[0], chars=32*numEvents), items=0, items=numEvents):
            i = 0
            while i < numEvents:
                with eventInfo = self.getEventInfo(events[i], outitems=EVENTS_FIELDS):
                    info[index + i*EVENTS_FIELDS] = events[i]
                    j = 1
                    while j < EVENTS_FIELDS:
                        info[index + i*EVENTS_FIELDS + j] = eventInfo[j]
                        j += 1
                i += 1
        index += numEvents*EVENTS_FIELDS

        # gather outcomes info:
        # [sharesPurchased, price, winningOutcomes...]
        k = 0
        while k < self.Markets[marketID].numOutcomes:
            info[index + k*OUTCOMES_FIELDS] = self.Markets[marketID].sharesPurchased[k + 1]
            k += 2
        index += self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS
        k = 0
        while k < WINNING_OUTCOMES_FIELDS:
            info[index + k] = self.Markets[marketID].winningOutcomes[k]
            k += 1
        index += WINNING_OUTCOMES_FIELDS

        # append description character codes
        info[index] = descriptionLength
        index += 1
        with description = self.getDescription(marketID, outchars=descriptionLength):
            c = 0
            while c < descriptionLength:
                info[index + c] = getch(description, c)
                c += 1
        return(info: arr)
        
# Gets all information about all markets on the specified branch and
# returns it as a giant array.  getMarketsInfo requires a great deal of gas.
# Invoke using eth_call with gas=9999999999999 (or other very large number).
# @param {int} branch Branch ID that we're retrieving markets on.
# @param {int} offset Starting market index (0=full load).
# @param {int} numMarketsToLoad How many markets to load (0=all markets).
# @return array Array containing all data for all markets:
#            [N, length_1, length_2, ..., length_N, info_1, info_2, ..., info_N]
#           where length_j is the number of elements stored for market j,
#           info_j is the information array for market j, and N is the total
#           number of markets in this branch.
def getMarketsInfo(branch, offset, numMarketsToLoad):
    refund()
    numMarkets = self.getNumMarketsBranch(branch)
    with marketIDs = self.getMarketsInBranch(branch, outitems=numMarkets):
        if numMarketsToLoad > 0 and numMarketsToLoad < numMarkets:
            numMarkets = numMarketsToLoad
        with marketsMatrix = array(numMarkets):
            with marketArrayLength = array(numMarkets):
                m = 0
                while m < numMarkets:
                    marketID = marketIDs[m + offset]
                    traderFields = 1 + self.Markets[marketID].numOutcomes
                    participantNumber = self.Markets[marketID].addr2participant[msg.sender]
                    descriptionLength = self.getDescriptionLength(marketID)
                    marketArrayLength[m] = FIELDS + self.Markets[marketID].currentParticipant*traderFields + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1
                    marketsMatrix[m] = self.getMarketInfo(marketID, outitems=marketArrayLength[m])
                    m += 1

                # flatten the markets info matrix so it can be returned
                # (data offset by 1+numMarkets so length data can be prepended)
                totalFlatLength = 1 + numMarkets
                m = 0
                while m < numMarkets:
                    totalFlatLength += marketArrayLength[m]
                    m += 1
                with flattened = array(totalFlatLength):
                    flattened[0] = numMarkets
                    m = 0
                    while m < numMarkets:
                        flattened[m + 1] = marketArrayLength[m]
                        m += 1
                    currentFlatLength = 1 + numMarkets
                    row = 0
                    while row < numMarkets:
                        col = 0
                        while col < marketArrayLength[row]:
                            flattened[currentFlatLength + col] = marketsMatrix[row][col]
                            col += 1
                        currentFlatLength += col
                        row += 1
                    return(flattened: arr)
                    
def getSender():
    return(msg.sender)
inset('refund.se')

# Events' index is the eventID
# a binary outcome has 0 for min && 1 for max value, but consensus will return ONE and TWO respectively
# so for voting 1 and 2 in fxp. need to be given for binaries, not 0 & 1
# S&P 500 scalar would be say 0 && 4700, respectively
# categorical markets have fixed point min and max
 # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, mode, uncaughtOutcome, ethical, originalExp, rejected, rejectedPeriod, rejectedUncaught, bond, forked, forkOver, forkOutcome, forkEthicality, resolutionSource[], resolutionSourceLength)

data past24Hours[]

def getForkOutcome(event):
    return(self.Events[event].forkOutcome)

def setForkOutcome(event, value):
    self.Events[event].forkOutcome = value
    return(1)
    
def getForkEthicality(event):
    return(self.Events[event].forkEthicality)

def setForkEthicality(event, value):
    self.Events[event].forkEthicality = value
    return(1)

def getForked(event):
    return(self.Events[event].forked)

def setForked(event):
    self.Events[event].forked = 1
    return(1)
    
def setForkDone(event):
    self.Events[event].forkOver = 1
    return(1)
    
def getForkedDone(event):
    return(self.Events[event].forkOver)

def getEventResolution(event):
    resLen = self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=resLen): str)

def getEventInfo(event):
    refund()
    eventinfo = array(7)
    eventinfo[0] = self.Events[event].branch
    eventinfo[1] = self.Events[event].expirationDate 
    eventinfo[2] = self.Events[event].outcome
    eventinfo[3] = self.Events[event].minValue
    eventinfo[4] = self.Events[event].maxValue
    eventinfo[5] = self.Events[event].numOutcomes
    eventinfo[6] = self.Events[event].bond
    return(eventinfo: arr)
    
def getResolution(event):
    refund()
    length=self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=length): str)

def getPast24(period):
    refund()
    return(self.past24Hours[period])

def addPast24(period):
    refund()
    self.past24Hours[period] += 1
    return(1)

def getEventBranch(event):
    refund()
    return(self.Events[event].branch)

def getExpiration(event):
    refund()
    return(self.Events[event].expirationDate)

def getOriginalExpiration(event):
    refund()
    return(self.Events[event].originalExp)

def setExpiration(event, date):
    refund()
    self.Events[event].expirationDate = date
    return(1)

def setBranch(event, branch):
    self.Events[event].branch = branch
    return(1)

def getOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].outcome)

def getEthics(event):
    refund()
    return(self.Events[event].ethical)

def setEthics(event, ethicality):
    refund()
    self.Events[event].ethical = ethicality
    return(ethicality)

def getEthical(event):
    refund()
    return(self.Events[event].ethical)

def getMinValue(event):
    refund()
    return(self.Events[event].minValue)

def getMaxValue(event):
    refund()
    return(self.Events[event].maxValue)

def getNumOutcomes(event):
    refund()
    return(self.Events[event].numOutcomes)

def setUncaughtOutcome(event, outcome):
    refund()
    self.Events[event].uncaughtOutcome = outcome
    return(1)

def getUncaughtOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].uncaughtOutcome)

def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    # check that msg.sender is one of our function contracts
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    if(self.Events[ID].expirationDate==0):
        self.Events[ID].branch = branch
        self.Events[ID].expirationDate = expirationDate
        self.Events[ID].originalExp = originalExp
        self.Events[ID].minValue = minValue
        self.Events[ID].maxValue = maxValue
        self.Events[ID].numOutcomes = numOutcomes
        save(self.Events[ID].resolutionSource[0], resolution, chars=len(resolution))
        return(1)
    else:
        return(0)

def setBond(event, bond):
    refund()
    self.Events[event].bond = bond
    return(1)

def addMarket(event, marketID):
    refund()
    self.Events[event].markets[self.Events[event].numMarkets] = marketID
    self.Events[event].numMarkets += 1
    return(1)

def getBranch(event):
    return(self.Events[event].branch)

def getBond(event):
    refund()
    return(self.Events[event].bond)

def getMarkets(event):
    refund()
    i = 0
    markets = array(self.Events[event].numMarkets)
    while i < self.Events[event].numMarkets:
        markets[i] = self.Events[event].markets[i]
        i += 1
    return(markets: arr)
    
def getMarket(event, marketIndex):
    refund()
    return(self.Events[event].markets[marketIndex])

def getNumMarkets(event):
    refund()
    return(self.Events[event].numMarkets)

def setOutcome(ID, outcome):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.Events[ID].outcome = outcome
    return(1)

def getReportingThreshold(event):
    refund()
    return(self.Events[event].threshold)
    
def setThreshold(event, threshold):
    # do whitelist
    self.Events[event].threshold = threshold
    return(1)

def getmode(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].mode)

def setmode(event, mode):
    refund()
    self.Events[event].mode = mode
    return(1)

def setRejected(event, period, uncaughtOutcome):
    refund()
    self.Events[event].rejected = 1
    self.Events[event].rejectedPeriod = period
    self.Events[event].rejectedUncaught = uncaughtOutcome
    return(1)
    

def getRejected(event):
    refund()
    return(self.Events[event].rejected)

def getRejectedPeriod(event):
    refund()
    return(self.Events[event].rejectedPeriod)

def getRejectedUncaught(event):
    refund()
    return(self.Events[event].rejectedUncaught)
inset('refund.se')

# reporter
data tradeCommits[](hash, block)
# tradeID
data trades[](id, type, market, amount, price, owner, block, outcome, initialTrade)

def makeTradeHash(max_value, max_amount, trade_ids: arr):
    refund()
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha256(tradeInfo, items=3)
    return(tradeHash)

def commitTrade(hash):
    refund()
    self.tradeCommits[msg.sender].hash = hash
    self.tradeCommits[msg.sender].block = block.number
    return(1)
    
def setInitialTrade(id):
    refund()
    self.trades[id].initialTrade = 1
    return(1)
    
def getInitialTrade(id):
    refund()
    return(self.trades[id].initialTrade)
    
def zeroHash():
    refund()
    self.tradeCommits[msg.sender].hash = 0
    return(1)

def checkHash(tradeHash, sender):
    refund()
    if(self.tradeCommits[sender].hash != tradeHash || block.number <= self.tradeCommits[sender].block):
        return(-1)
    else:
        return(1)
        
def getID(tradeID):
    refund()
    return(self.trades[tradeID].id)
    
def saveTrade(trade_id, type, market, amount, price, sender, outcome):
    refund()
    self.trades[trade_id].id = trade_id
    self.trades[trade_id].type = type
    self.trades[trade_id].market = market
    self.trades[trade_id].amount = amount
    self.trades[trade_id].price = price
    self.trades[trade_id].owner = sender
    self.trades[trade_id].block = block.number
    self.trades[trade_id].outcome = outcome
    return(1)

def get_trade(id):
    refund()
    trade = array(8)
    trade[0] = self.trades[id].id
    trade[1] = self.trades[id].type
    trade[2] = self.trades[id].market
    trade[3] = self.trades[id].amount
    trade[4] = self.trades[id].price
    trade[5] = self.trades[id].owner
    trade[6] = self.trades[id].block
    trade[7] = self.trades[id].outcome
    if trade:
        return(trade:arr)
    return([0]:arr)

def get_amount(id):
    refund()
    return(self.trades[id].amount)
    
def get_price(id):
    refund()
    return(self.trades[id].price)

def update_trade(id, price):
    refund()
    self.trades[id].price = price
    self.trades[id].block = block.number

def remove_trade(id):
    refund()
    self.trades[id].id = 0
    self.trades[id].type = 0
    self.trades[id].market = 0
    self.trades[id].amount = 0
    self.trades[id].price = 0
    self.trades[id].owner = 0
    self.trades[id].block = 0
    self.trades[id].outcome = 0
    return(1)
    
def fill_trade(id, fill):
    refund()
    self.trades[trade_id].amount -= fill
    return(1)
inset('refund.se')

data cashcoinBalances[]

data owners[]


# @return: cash balance of address
def balance(address):
    refund()
    return(self.cashcoinBalances[address])

# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...
# needs to be called when making a market, branch, etc. or a new cash user acc.
def initiateOwner(account):
    refund()
    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):
        self.owners[account] = msg.sender
        return(1)
    else:
        return(0)

# should send values as fixed point in UI (1 is ONE, 4 is 4*ONE, .5 is ONEHALF, etc.)
# @return: value sent, 0 if fails
# If you've never used cash in augur, to initiate your account call this with value as 0
def send(recver, value):
    refund()
    if(self.owners[msg.sender]==0):
        self.owners[msg.sender] = msg.sender
    #if(self.owners[recver]==0):
    #    return(0)
    sender = msg.sender
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    refund()
    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.
    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)
    if(from!=tx.origin and msg.sender!=self.owners[from] and msg.sender!=from):
        return(0)
    #if(self.owners[recver]==0):
    #    return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# make sure only coming from specific contracts
def subtractCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    #if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):
    #    return(0)
    self.cashcoinBalances[ID] -= amount
    return(1)

def addCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.cashcoinBalances[ID] += amount
    return(1)

def setCash(address, balance):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    self.cashcoinBalances[address] = balance
    return(1)

def depositEther():
    self.cashcoinBalances[msg.sender] += msg.value * ONE / WEITOETH
    return msg.value

def withdrawEther(to, value):
    if(value < 0):
        return(-1)
    if self.cashcoinBalances[msg.sender] >= value * ONE / WEITOETH:
        self.cashcoinBalances[msg.sender] -= value * ONE / WEITOETH
        send(to, value)
        return 1
    else:
        return 0

